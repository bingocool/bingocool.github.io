<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="cilibili">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="cilibili">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cilibili">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>cilibili</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cilibili</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/redis笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cilibili">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/redis笔记/" itemprop="url">redis笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-12T19:58:55+08:00">
                2019-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><a href="redis笔记/Redis3.2.x单机安装(new).docx">详见文档</a></p>


<h2 id="Redis单机部署"><a href="#Redis单机部署" class="headerlink" title="Redis单机部署"></a>Redis单机部署</h2><ol>
<li>下载、上传redis-3.2.11.tar.gz到服务器并解压</li>
<li>进入到源码包中，编译并安装redis，预先下载gcc（c 的编译器）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">cd /usr/local/src/redis-3.2.11/</span><br><span class="line">make MALLOC=libc &amp;&amp; make install  #内存分配</span><br></pre></td></tr></table></figure>

<ol>
<li>在所有机器的/usr/local/下创建一个redis目录，然后拷贝redis配置文件redis.conf到/usr/local/redis</li>
<li>修改所有机器的配置文件redis.conf</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes  #redis后台运行</span><br><span class="line"><span class="meta">#</span>cluster-enabled yes  #开集群后把注释去掉</span><br><span class="line">appendonly yes  #开启aof日志，它会每次写操作都记录一条日志</span><br><span class="line">bind 192.168.1.207</span><br></pre></td></tr></table></figure>

<ol>
<li>启动所有的redis节点</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /usr/local/redis/redis.conf  #make&amp;&amp;make install 就已经把redis添加到环境变量了</span><br></pre></td></tr></table></figure>

<ol>
<li>使用命令行客户的连接redis</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.1.207</span><br><span class="line">redis-cli -p 6379 #-p为redis进程号，通过ps -ef | grep redis查询</span><br></pre></td></tr></table></figure>

<p>Tips:</p>
<ol>
<li>配置redis密码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set requirepass 123</span><br></pre></td></tr></table></figure>

<ol>
<li>再次连接的时候输入密码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth 123</span><br></pre></td></tr></table></figure>

<h2 id="Redis-JavaAPI操作"><a href="#Redis-JavaAPI操作" class="headerlink" title="Redis-JavaAPI操作"></a>Redis-JavaAPI操作</h2><p>导入Redis依赖</p>
<ol>
<li>定义连接池参数，获取连接池方法</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">JedisPoolConfig</span>()</span><br><span class="line"><span class="comment">//最大连接数,</span></span><br><span class="line">config.setMaxTotal(<span class="number">20</span>)</span><br><span class="line"><span class="comment">//最大空闲连接数</span></span><br><span class="line">config.setMaxIdle(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//当调用borrow Object方法时，是否进行有效性检查 --&gt;</span></span><br><span class="line">config.setTestOnBorrow(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">//10000代表超时时间（10秒）</span></span><br><span class="line"><span class="keyword">val</span> pool = <span class="keyword">new</span> <span class="type">JedisPool</span>(config, <span class="string">"192.168.1.207"</span>, <span class="number">6379</span>, <span class="number">10000</span>, <span class="string">"123"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getConnection</span></span>(): <span class="type">Jedis</span> = &#123;</span><br><span class="line">  pool.getResource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conn = <span class="type">JedisConnectionPool</span>.getConnection()</span><br><span class="line">conn.set(<span class="string">"income"</span>, <span class="string">"1000"</span>)</span><br><span class="line"><span class="keyword">val</span> r1 = conn.get(<span class="string">"xiaoniu"</span>)</span><br><span class="line">conn.incrBy(<span class="string">"xiaoniu"</span>, <span class="number">-50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.<span class="type">JavaConversions</span>._  <span class="comment">//导入隐式函数把java集合转成scala集合</span></span><br><span class="line"><span class="keyword">val</span> r = conn.keys(<span class="string">"*"</span>)  <span class="comment">//获得所有的key</span></span><br><span class="line"><span class="keyword">for</span> (p &lt;- r) &#123;	<span class="comment">//打印所有的key</span></span><br><span class="line">  println(p + <span class="string">" : "</span> + conn.get(p))</span><br><span class="line">&#125;</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/kafka笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cilibili">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/kafka笔记/" itemprop="url">kafka笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-12T19:58:55+08:00">
                2019-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h1><p>首先在pom里导入kafka依赖（只使用kafka，不使用spark等）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>Broker</strong>： 安装Kafka服务的那台集群就是一个broker（broker的id要全局唯一）</p>
<p><strong>Producer</strong> ：消息的生产者，负责将数据写入到broker中（push）</p>
<p><strong>Consumer</strong>：消息的消费者，负责从kafka中读取数据（pull），老版本的消费者需要依赖zk，新版本的不需要</p>
<p><strong>Topic</strong>: 主题，相当于是数据的一个分类，不同topic存放不同的数据</p>
<p><strong>partition</strong>：分区，是一个物理的分区，一个分区就算一个文件，一个topic可以有一到多个分区，每一个分区都有自己的副本</p>
<p><strong>replication</strong>：副本，数据保存多少份</p>
<p><strong>Consumer Group</strong>： 消费者组，一个topic可以有多个消费者同时消费，多个消费者如果在一个消费者组中，那么他们不会重复消费数据</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>0.安装zookeeper集群，保证zookeeper集群可以使用<br>1.上传Kafka安装包并解压<br>2.修改配置文件 config/server.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">broker.id=0 #每台机器都不唯一1、2、3...</span><br><span class="line">port=9092	#默认的</span><br><span class="line">host.name=node-4  #broker连接的IP地址或主机名,每台机器不同 node-5、6...</span><br><span class="line">log.dirs=/data/kafka  #kafka保存数据的路径</span><br><span class="line">zookeeper.connect=node-1:2181,node-2:2181,node-3:2181</span><br><span class="line">delete.topic.enable=true  #删除topic（否则为删除的时候只是挂了个标签）</span><br></pre></td></tr></table></figure>

<p>3.将配置好的kafka拷贝到其他机器上<br>4.在其他机器上修改broker.id和host.name（不同）<br>5.启动kafka    （副本数量不能大于启动的kafka节点数）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>KAFKA_HOME/bin/kafka-server-start.sh -daemon $KAFKA_HOME/config/server.properties 	#-daemon 显示在后台</span><br></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li>启动kafka</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>-daemon 显示在后台</span><br><span class="line"><span class="meta">$</span>KAFKA_HOME/bin/kafka-server-start.sh -daemon $KAFKA_HOME/config/server.properties</span><br></pre></td></tr></table></figure>

<ul>
<li>停止kafka</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>KAFKA_HOME/bin/kafka-server-stop.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>创建topic</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>KAFKA_HOME/bin/kafka-topics.sh --create --zookeeper node-1:2181,node-2:2181,node-3:2181 --replication-factor 3 --partitions 3 --topic my-topic</span><br></pre></td></tr></table></figure>

<ul>
<li>列出所有topic</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>KAFKA_HOME/bin/kafka-topics.sh --list --zookeeper node-1:2181,node-2:2181,node-3:2181</span><br></pre></td></tr></table></figure>

<ul>
<li>查看某个topic信息（topic信息&lt;topic名字，分区副本等&gt;保存在zookeeper集群中）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>KAFKA_HOME/bin/kafka-topics.sh --describe --zookeeper node-1:2181,node-2:2181,node-3:2181 --topic my-topic</span><br></pre></td></tr></table></figure>

<ul>
<li>启动一个命令行的生产者（生产者往kafka里写不需要知道zookeeper在哪）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>KAFKA_HOME/bin/kafka-console-producer.sh --broker-list node-1:9092,node-1.xiaoniu.xom:9092,node-3:9092 --topic xiaoniu</span><br></pre></td></tr></table></figure>

<ul>
<li>启动一个命令行的消费者（消费者需要从zookeeper知道数据位置、数据偏移量等信息）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>--from-beginning:可以消费以前的数据</span><br><span class="line"><span class="meta">$</span>KAFKA_HOME/bin/kafka-console-consumer.sh --zookeeper node-1:2181,node-2:2181,node-3:2181 --topic my-topic --from-beginning</span><br></pre></td></tr></table></figure>

<ul>
<li>消费者连接到borker的地址</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>KAFKA_HOME/bin/kafka-console-consumer.sh --bootstrap-server node-1:9092,node-2:9092,node-3:9092 --topic xiaoniu --from-beginning</span><br></pre></td></tr></table></figure>

<h2 id="Kafka-Java-API"><a href="#Kafka-Java-API" class="headerlink" title="Kafka-Java-API"></a>Kafka-Java-API</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">		props.put(<span class="string">"metadata.broker.list"</span>, <span class="string">"node-4:9092,node-5:9092,node-6:9092"</span>);</span><br><span class="line">		props.put(<span class="string">"serializer.class"</span>, <span class="string">"kafka.serializer.StringEncoder"</span>);</span><br><span class="line">		ProducerConfig config = <span class="keyword">new</span> ProducerConfig(props);</span><br><span class="line">		Producer&lt;String, String&gt; producer = <span class="keyword">new</span> Producer&lt;String, String&gt;(config);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1001</span>; i &lt;= <span class="number">1100</span>; i++)</span><br><span class="line">			producer.send(<span class="keyword">new</span> KeyedMessage&lt;String, String&gt;(<span class="string">"xiaoniu"</span>, <span class="string">"xiaoniu-msg"</span> + i));<span class="comment">//&lt;topic,message&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String topic = <span class="string">"xiaoniu"</span>;</span><br><span class="line">	<span class="comment">//一个消费者必须两个线程以上同时消费</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer threads = <span class="number">2</span>; </span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">		<span class="comment">//此为老版本，需要指定zookeeper地址</span></span><br><span class="line">		props.put(<span class="string">"zookeeper.connect"</span>, <span class="string">"node-1:2181,node-2:2181,node-3:2181"</span>); </span><br><span class="line">		props.put(<span class="string">"group.id"</span>, <span class="string">"vvvvv"</span>);</span><br><span class="line">		<span class="comment">//smallest重最开始消费,largest重消费者启动后产生的数据才消费</span></span><br><span class="line">		<span class="comment">//等同--from-beginning</span></span><br><span class="line">		props.put(<span class="string">"auto.offset.reset"</span>, <span class="string">"smallest"</span>);</span><br><span class="line"></span><br><span class="line">		ConsumerConfig config = <span class="keyword">new</span> ConsumerConfig(props);</span><br><span class="line">		ConsumerConnector consumer =Consumer.createJavaConsumerConnector(config);</span><br><span class="line">		Map&lt;String, Integer&gt; topicCountMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">		topicCountMap.put(topic, threads);</span><br><span class="line">		Map&lt;String, List&lt;KafkaStream&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt;&gt; consumerMap = consumer.createMessageStreams(topicCountMap);</span><br><span class="line">		List&lt;KafkaStream&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt; streams = consumerMap.get(topic);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">final</span> KafkaStream&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; kafkaStream : streams)&#123;</span><br><span class="line">			<span class="comment">//因为指定了两个线程进行消费</span></span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">for</span>(MessageAndMetadata&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; mm : kafkaStream)&#123;</span><br><span class="line">						String msg = <span class="keyword">new</span> String(mm.message());</span><br><span class="line">						System.out.println(msg);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/05/Vue学习总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cilibili">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/Vue学习总结/" itemprop="url">Vue学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-05T10:07:20+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Vue学习总结"><a href="#Vue学习总结" class="headerlink" title="Vue学习总结"></a>Vue学习总结</h1><p><strong>Tips</strong>：使用Vue需要有node.js环境</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1)  借鉴 angular 的模板和<u>数据绑定技术</u> </p>
<p>2)  借鉴 react 的组件化和<u>虚拟 DOM 技术</u></p>
<p><strong>扩展插件</strong></p>
<p>1) vue-cli:vue 脚手架 </p>
<p>2) vue-resource(axios):ajax 请求 </p>
<p>3) vue-router: 路由 </p>
<p>4) vuex: 状态管理 </p>
<p>5) vue-lazyload: 图片懒加载 </p>
<p>6) vue-scroller: 页面滑动相关 </p>
<p>7) mint-ui: 基于 vue 的 UI 组件库(移动端) </p>
<p>8) element-ui: 基于 vue 的 UI 组件库(PC 端)</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="常用内置指令"><a href="#常用内置指令" class="headerlink" title="常用内置指令"></a>常用内置指令</h3><p>1) v-text: 更新元素的 textContent </p>
<p>2) v-html: 更新元素的 innerHTML </p>
<p>3) v-if: 如果为 true, 当前标签才会输出到页面</p>
<p>4) v-else: 如果为 false, 当前标签才会输出到页面 </p>
<p>5) v-show: 通过控制 display 样式来控制显示/隐藏 </p>
<p>6) v-for: 遍历数组/对象 </p>
<p>7) v-on: 绑定事件监听, 一般简写为@ </p>
<ul>
<li>默认事件形参:event 、隐含属性对象:$event</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=<span class="string">"test2($event, 'hello')"</span>&gt;Greet3&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/method代码</span></span><br><span class="line"><span class="regexp">test2 (event, msg) &#123;</span></span><br><span class="line"><span class="regexp">    alert(event.target.innerHTML + '---' + msg) </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>按键修饰符</p>
<p>1) .keycode: 操作的是某个 keycode 值的键 </p>
<p>2) .keyName: 操作的某个按键名的键(少部分)</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input @keyup<span class="number">.8</span>=<span class="string">"test6"</span>&gt;</span><br><span class="line">&lt;input @keyup.enter=<span class="string">"test6"</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>事件修饰符：</p>
<p>1) .prevent: 阻止事件的默认行为 event.preventDefault() </p>
<p>2) .stop: 停止事件冒泡 event.stopPropagation()</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!-阻止事件默认行为</span> (阻止<span class="attr">href</span>的路径)<span class="attr">--</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> @<span class="attr">click.prevent</span>=<span class="string">"test3"</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">!-停止事件冒泡</span> (不会触发下层的事件)<span class="attr">--</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 200px;background: red"</span> @<span class="attr">click</span>=<span class="string">"test4"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100px;height: 100px;background: green"</span> @<span class="attr">click.stop</span>=<span class="string">"test5"</span></span></span><br><span class="line">    &lt;/div&gt; </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>8) v-bind: 强制绑定解析表达式, 一般简写为 ：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>访问指定站点 2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>9) v-model: 双向数据绑定 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--textarea--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"user.desc"</span> <span class="attr">rows</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--radio--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"female"</span> <span class="attr">value</span>=<span class="string">"female"</span> <span class="attr">v-model</span>=<span class="string">"user.sex"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"female"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"male"</span> <span class="attr">value</span>=<span class="string">"male"</span> <span class="attr">v-model</span>=<span class="string">"user.sex"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"male"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--checkbox--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"basket"</span> <span class="attr">value</span>=<span class="string">"basketball"</span> <span class="attr">v-model</span>=<span class="string">"user.likes"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"basket"</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"foot"</span> <span class="attr">value</span>=<span class="string">"football"</span> <span class="attr">v-model</span>=<span class="string">"user.likes"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"foot"</span>&gt;</span>足球<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--checkbox--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"user.cityId"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>未选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">"city in allCitys"</span> <span class="attr">:value</span>=<span class="string">"city.id"</span>&gt;</span> &#123;&#123; city.name &#125;&#125; <span class="tag">&lt;/<span class="name">option</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>10) v-ref: 指定唯一标识,vue 对象通过$els 属性访问这个元素对象 </p>
<p>11) v-cloak: 防止闪现, 与 css 配合:[v-cloak]{display:none}</p>
<h3 id="计算属性-amp-监视属性"><a href="#计算属性-amp-监视属性" class="headerlink" title="计算属性&amp;监视属性"></a>计算属性&amp;监视属性</h3><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>1) 在 computed 属性对象中定义计算属性的方法 </p>
<p>2) 在页面中使用来显示计算的结果</p>
<h4 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a>监视属性</h4><p>1) 通过通过 vm 对象的$watch()或 watch 配置来监视指定的属性 </p>
<p>2) 当属性变化时, 回调函数自动调用, 在函数内部进行计算</p>
<h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>html代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">    姓: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"First Name"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Last Name"</span> <span class="attr">v-model</span>=<span class="string">"lastName"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    姓名 1(单向): <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Full Name"</span> <span class="attr">v-model</span>=<span class="string">"fullName1"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    姓名 2(单向): <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Full Name"</span> <span class="attr">v-model</span>=<span class="string">"fullName2"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    姓名 3(双向): <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Full Name2"</span> <span class="attr">v-model</span>=<span class="string">"fullName3"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>vue js代码</p>
<p><strong>计算属性高级</strong> ：（重点学习fullName3）<br> 通过 getter/setter 实现对属性数据的显示和监视</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#demo'</span>, </span><br><span class="line">    data: &#123;</span><br><span class="line">        firstName: <span class="string">'Kobe'</span>, <span class="attr">lastName</span>: <span class="string">'bryant'</span>, <span class="attr">fullName2</span>: <span class="string">'Kobe bryant'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        fullName3: &#123;</span><br><span class="line">            <span class="keyword">get</span>: function () &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>: function (value) &#123;</span><br><span class="line">                <span class="keyword">var</span> names = value.split(<span class="string">' '</span>)</span><br><span class="line">                <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">this</span>.lastName = names[<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        lastName: <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.fullName2 = <span class="keyword">this</span>.firstName + <span class="string">' '</span> + newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.$watch(<span class="string">'firstName'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fullName2 = val + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Class绑定-amp-Style绑定与过渡-amp-动画"><a href="#Class绑定-amp-Style绑定与过渡-amp-动画" class="headerlink" title="Class绑定&amp;Style绑定与过渡&amp;动画"></a>Class绑定&amp;Style绑定与过渡&amp;动画</h3><h4 id="Class绑定-amp-Style绑定"><a href="#Class绑定-amp-Style绑定" class="headerlink" title="Class绑定&amp;Style绑定"></a>Class绑定&amp;Style绑定</h4><p>1) 在应用界面中, 某个(些)元素的样式是变化的 </p>
<p>2) class/style 绑定就是专门用来实现动态样式效果的技术</p>
<h5 id="Class绑定"><a href="#Class绑定" class="headerlink" title="Class绑定"></a>Class绑定</h5><p>1) :class=’xxx’ </p>
<p>2) 表达式是字符串:’classA’ </p>
<p>3) 表达式是对象:{classA:isA,classB:isB} </p>
<p>4) 表达式是数组:[‘classA’,’classB’]</p>
<h5 id="Style绑定"><a href="#Style绑定" class="headerlink" title="Style绑定"></a>Style绑定</h5><p>1) :style=”{color:activeColor,fontSize:fontSize+’px’}” </p>
<p>2) 其中 activeColor/fontSize 是 data 属性</p>
<h5 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h5><p>CSS代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line"><span class="selector-class">.classA</span> &#123; <span class="attribute">color</span>: red; &#125; </span><br><span class="line"><span class="selector-class">.classB</span> &#123;<span class="attribute">background</span>: blue;&#125; </span><br><span class="line"><span class="selector-class">.classC</span> &#123; <span class="attribute">font-size</span>: <span class="number">20px</span>; &#125; </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>HTML代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>1. class 绑定: :class='xxx'<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"classB"</span> <span class="attr">:class</span>=<span class="string">"a"</span>&gt;</span>表达式是字符串: 'classA'<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"&#123;classA: isA, classB: isB&#125;"</span>&gt;</span>表达式是对象: &#123;classA:isA, classB: isB&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"['classA', 'classC']"</span>&gt;</span> 表达式是数组: ['classA', 'classB']<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>2. style 绑定<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">"&#123;color, fontSize&#125;"</span>&gt;</span>style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"update"</span>&gt;</span>更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Vue  JS 代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"../js/vue.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> </span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt; </span><br><span class="line">    <span class="keyword">new</span> Vue(&#123; </span><br><span class="line">    	el : <span class="string">'#demo'</span>, </span><br><span class="line">    	data : &#123; </span><br><span class="line">            a: <span class="string">'classA'</span>, </span><br><span class="line">            isA: <span class="literal">true</span>, </span><br><span class="line">            isB: <span class="literal">false</span>, </span><br><span class="line">            color: <span class="string">'red'</span>, </span><br><span class="line">            fontSize: <span class="string">'20px'</span> </span><br><span class="line">        &#125;, <span class="attr">methods</span> : &#123; </span><br><span class="line">            update () &#123; </span><br><span class="line">                <span class="keyword">this</span>.a = <span class="string">'classC'</span> </span><br><span class="line">                <span class="keyword">this</span>.isA = <span class="literal">false</span> </span><br><span class="line">                <span class="keyword">this</span>.isB = <span class="literal">true</span> </span><br><span class="line">                <span class="keyword">this</span>.color = <span class="string">'blue'</span> </span><br><span class="line">                <span class="keyword">this</span>.fontSize = <span class="string">'30px'</span> </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">	&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡&amp;动画"></a>过渡&amp;动画</h4><h5 id="Vue-动画的理解"><a href="#Vue-动画的理解" class="headerlink" title="Vue 动画的理解"></a>Vue 动画的理解</h5><p>1) 操作 css 的 trasition 或 animation </p>
<p>2) vue 会给目标元素添加/移除特定的 class </p>
<p>3) 过渡的相关类名 </p>
<ul>
<li><p>xxx-enter-active: 指定显示的 transition </p>
</li>
<li><p>xxx-leave-active: 指定隐藏的 transition </p>
</li>
<li><p>xxx-enter/xxx-leave-to: 指定隐藏时的样式</p>
<p>Tips：<code>xxx-leave-to</code>)2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>xxx-enter</code> 被移除)，在过渡/动画完成之后移除。</p>
</li>
</ul>
<p><img src="//yoursite.com/2019/08/05/Vue学习总结/transition.png" alt="Vue过渡"></p>
<img src="/2019/08/05/Vue学习总结/transition.png">

<h5 id="基本过渡动画的编码"><a href="#基本过渡动画的编码" class="headerlink" title="基本过渡动画的编码"></a>基本过渡动画的编码</h5><p>1) 在目标元素外包裹 &lt;transitionname=”xxx”&gt; </p>
<p>2) 定义 class 样式 </p>
<ul>
<li><p>指定过渡样式: transition </p>
</li>
<li><p>指定隐藏时的样式: opacity/其它</p>
</li>
</ul>
<h5 id="过渡应用实例"><a href="#过渡应用实例" class="headerlink" title="过渡应用实例"></a>过渡应用实例</h5><p>CSS代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line">    <span class="selector-class">.fade-enter-active</span>, <span class="selector-class">.fade-leave-active</span> &#123;</span><br><span class="line">        <span class="attribute">transition</span>: opacity .<span class="number">5s</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.fade-enter</span>, <span class="selector-class">.fade-leave-to</span> &#123; </span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*可 以 设 置 不 同 的 进 入 和 离 开 动 画*/</span></span><br><span class="line">    <span class="selector-class">.slide-fade-enter-active</span> &#123;</span><br><span class="line">        <span class="attribute">transition</span>: all .<span class="number">3s</span> ease; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="selector-class">.slide-fade-leave-active</span> &#123;</span><br><span class="line">        <span class="attribute">transition</span>: all .<span class="number">8s</span> <span class="built_in">cubic-bezier</span>(1.0, 0.5, 0.8, 1.0); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="selector-class">.slide-fade-enter</span>, <span class="selector-class">.slide-fade-leave-to</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translateX</span>(10px); <span class="attribute">opacity</span>: <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>HTML代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show = !show"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"slide-fade"</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="动画应用实例"><a href="#动画应用实例" class="headerlink" title="动画应用实例"></a>动画应用实例</h5><p>CSS代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line">    <span class="selector-class">.bounce-enter-active</span> &#123;</span><br><span class="line">        <span class="attribute">animation</span>: bounce-in .<span class="number">5s</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.bounce-leave-active</span> &#123;</span><br><span class="line">        <span class="attribute">animation</span>: bounce-in .<span class="number">5s</span> reverse; </span><br><span class="line">    &#125;</span><br><span class="line">	&lt;!<span class="selector-tag">--bounce-in</span>是自定义的<span class="selector-tag">animation--</span>&gt;</span><br><span class="line">    @<span class="keyword">keyframes</span> bounce-in &#123; </span><br><span class="line">        0% &#123;<span class="attribute">transform</span>: <span class="built_in">scale</span>(0);&#125; </span><br><span class="line">        50% &#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(1.5); &#125; </span><br><span class="line">        100% &#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(1); &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>HTML代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show = !show"</span>&gt;</span>Toggle show<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"bounce"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span> <span class="attr">style</span>=<span class="string">"display: inline-block"</span>&gt;</span>Look at me!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="条件渲染-amp-列表渲染"><a href="#条件渲染-amp-列表渲染" class="headerlink" title="条件渲染&amp;列表渲染"></a>条件渲染&amp;列表渲染</h3><h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><p>1) v-if 与 v-else </p>
<p>2) v-show</p>
<p><strong>比较 v-if 与 v-show</strong></p>
<p>3) 如果需要频繁切换 v-show 较好 </p>
<p><strong>4)</strong> 当条件不成立时,v-if 的所有子节点不会解析(项目中使用)</p>
<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><p><strong>1) 列表显示指令</strong> </p>
<p>数组:v-for/index </p>
<p>对象:v-for/key </p>
<p><strong>2) 列表的更新显示</strong> </p>
<p>删除 item </p>
<p>替换 item </p>
<p><strong>3) 列表的高级处理</strong></p>
<p>列表过滤</p>
<p>列表排序</p>
<h4 id="维护状态（v-for-的key属性）"><a href="#维护状态（v-for-的key属性）" class="headerlink" title="维护状态（v-for 的key属性）"></a>维护状态（v-for 的key属性）</h4><p>当 Vue 正在更新使用 <code>v-for</code> 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 <code>track-by=&quot;$index&quot;</code>。</p>
<p>这个默认的模式是高效的，但是<strong>只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</strong>。</p>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code> attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p>
<p>因为它是 Vue 识别节点的一个通用机制，<code>key</code> 并不仅与 <code>v-for</code> 特别关联。后面我们将在指南中看到，它还具有其它用途。</p>
<p><strong>注意</strong>!!!!!</p>
<p>不要使用对象或数组之类的非基本类型值作为 <code>v-for</code> 的 <code>key</code>。请用字符串或数值类型的值。</p>
<h4 id="应用实例1（列表遍历与更新）"><a href="#应用实例1（列表遍历与更新）" class="headerlink" title="应用实例1（列表遍历与更新）"></a>应用实例1（列表遍历与更新）</h4><p>HTML代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>测试: v-for 遍历数组<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(p, index) in persons"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span> </span><br><span class="line">            &#123;&#123;index&#125;&#125;--&#123;&#123;p.name&#125;&#125;--&#123;&#123;p.age&#125;&#125; </span><br><span class="line">            --</span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"deleteItem(index)"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">            --</span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"updateItem(index, &#123;name:'Jok',age:15&#125;)"</span>&gt;</span>更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>测试: v-for 遍历对象<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(value, key) in persons[0]"</span>&gt;</span> </span><br><span class="line">            &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125; </span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"../js/vue.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> </span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt; </span><br><span class="line">    <span class="keyword">new</span> Vue(&#123; </span><br><span class="line">        el: <span class="string">'#demo'</span>, </span><br><span class="line">        data: &#123; </span><br><span class="line">            persons: [ </span><br><span class="line">                &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'Tom'</span>, <span class="attr">age</span>: <span class="number">13</span>&#125;, </span><br><span class="line">                &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'Jack'</span>, <span class="attr">age</span>: <span class="number">12</span>&#125;, </span><br><span class="line">                &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">'Bob'</span>, <span class="attr">age</span>: <span class="number">14</span>&#125; ] </span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123; </span><br><span class="line">            deleteItem(index) &#123; </span><br><span class="line">                <span class="keyword">this</span>.persons.splice(index, <span class="number">1</span>) </span><br><span class="line">            &#125;, </span><br><span class="line">            updateItem(index, p) &#123; </span><br><span class="line">                <span class="comment">// this.persons[index] = p //页面不会更新 </span></span><br><span class="line">                <span class="keyword">this</span>.persons.splice(index, <span class="number">1</span>, p)  <span class="comment">//页面更新 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;) </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a>变异方法</h4><p>Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>
<ul>
<li><p><code>splice()</code> ：有三个参数，第一个是想要删除的元素的下标（必选），第二个是想要删除的个数（必选），第三个是删除后想要在原位置替换的值（可选）====可以实现基本的增删改操作====</p>
<p>this.persons.splice(index, 1)  //删除，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置</p>
<p>this.persons.splice(index, 1, p)  //页面更新 </p>
<p>this.persons.splice(index, 0, p)  //页面新增，如果设置为 0，则不会删除项目。</p>
</li>
<li><p>push()： 往数组最后面添加一个元素，成功返回当前数组的长度</p>
</li>
<li><p>pop()：删除数组的最后一个元素，成功返回删除元素的值</p>
</li>
<li><p>shift()：删除数组的第一个元素，成功返回删除元素的值</p>
</li>
<li><p>unshift()：往数组最前面添加一个元素，成功返回当前数组的长度</p>
</li>
<li><p>sort()：使数组按照字符编码默认从小到大排序,成功返回排序后的数组</p>
</li>
<li><p>reverse()：将数组倒序，成功返回倒序后的数组</p>
</li>
</ul>
<h4 id="应用实例2（列表过滤与排序）"><a href="#应用实例2（列表过滤与排序）" class="headerlink" title="应用实例2（列表过滤与排序）"></a>应用实例2（列表过滤与排序）</h4><p>HTML代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"searchName"</span> <span class="attr">placeholder</span>=<span class="string">"搜索指定用户名"</span> <span class="attr">v-model</span>=<span class="string">"searchName"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(p, index) in filterPerson"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span> </span><br><span class="line">            &#123;&#123;index&#125;&#125;--&#123;&#123;p.name&#125;&#125;--&#123;&#123;p.age&#125;&#125; </span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"setOrderType(1)"</span>&gt;</span>年龄升序<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"setOrderType(2)"</span>&gt;</span>年龄降序<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"setOrderType(0)"</span>&gt;</span>原本顺序<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"../js/vue.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> </span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt; </span><br><span class="line">    <span class="keyword">new</span> Vue(&#123; </span><br><span class="line">        el: <span class="string">'#demo'</span>, </span><br><span class="line">        data: &#123; <span class="attr">orderType</span>: <span class="number">0</span>, <span class="comment">//0 代 表 不 排 序 , 1 为 升 序 , 2 为 降 序 </span></span><br><span class="line">               searchName: <span class="string">''</span>, </span><br><span class="line">               persons: [ </span><br><span class="line">                   &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'Tom'</span>, <span class="attr">age</span>: <span class="number">13</span>&#125;, </span><br><span class="line">                   &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'Jack'</span>, <span class="attr">age</span>: <span class="number">12</span>&#125;] &#125;, </span><br><span class="line">        methods: &#123; </span><br><span class="line">            setOrderType (orderType) &#123; </span><br><span class="line">                <span class="keyword">this</span>.orderType = orderType </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;, </span><br><span class="line">        computed: &#123; </span><br><span class="line">            filterPerson() &#123; </span><br><span class="line">                <span class="keyword">let</span> &#123;orderType, searchName, persons&#125; = <span class="keyword">this</span> </span><br><span class="line">                <span class="comment">// 按搜索的名字过滤 </span></span><br><span class="line">                persons = persons.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.name.indexOf(searchName)!=<span class="number">-1</span>)</span><br><span class="line">                <span class="comment">// 排序 </span></span><br><span class="line">                <span class="keyword">if</span>(orderType!==<span class="number">0</span>) &#123; </span><br><span class="line">                    persons = persons.sort(<span class="function"><span class="keyword">function</span> (<span class="params">p1, p2</span>) </span>&#123; </span><br><span class="line">                        <span class="keyword">if</span>(orderType===<span class="number">1</span>) &#123; </span><br><span class="line">                            <span class="keyword">return</span> p1.age-p2.age </span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                            <span class="keyword">return</span> p2.age-p1.age </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125;) </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">return</span> persons</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>功能: 对要显示的数据进行特定格式化后再显示</p>
<p>注意: 并没有改变原本的数据, 可是产生新的对应的数据</p>
<h4 id="定义和使用过滤器"><a href="#定义和使用过滤器" class="headerlink" title="定义和使用过滤器"></a>定义和使用过滤器</h4><p>1) 定义过滤器 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(filterName, <span class="function"><span class="keyword">function</span>(<span class="params">value[,arg1,arg2,...]</span>)</span>&#123; </span><br><span class="line">    <span class="comment">// 进行一定的数据处理 returnnewValue </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2) 使用过滤器 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;myData|filterName&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;myData|filterName(arg)&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h4><p>HTML代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前时间 1 为: &#123;&#123;currentTime | dateStr&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>当前时间 2 为: &#123;&#123;currentTime | dateStr('YYYY-MM-DD')&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>当前时间 3 为: &#123;&#123;currentTime | dateStr('HH:mm:ss')&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"../js/vue.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> </span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>src=<span class="string">"https://cdn.bootcss.com/moment.js/2.19.0/moment.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> </span><br><span class="line">&lt;script&gt; </span><br><span class="line">    <span class="comment">// 注册过滤器 </span></span><br><span class="line">    Vue.filter(<span class="string">'dateStr'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value, format</span>) </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> moment(value).format(format || <span class="string">'YYYY-MM-DD HH:mm:ss'</span>) </span><br><span class="line">	&#125;)</span><br><span class="line">    <span class="keyword">new</span> Vue(&#123; </span><br><span class="line">        el: <span class="string">'#test'</span>, </span><br><span class="line">        data: &#123; </span><br><span class="line">            currentTime: <span class="keyword">new</span> <span class="built_in">Date</span>() </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;) </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><h4 id="生命周期流程图"><a href="#生命周期流程图" class="headerlink" title="生命周期流程图"></a>生命周期流程图</h4><p><img src="//yoursite.com/2019/08/05/Vue学习总结/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="生命周期图"></p>
<img src="/2019/08/05/Vue学习总结/Vue生命周期.png">

<h4 id="Vue-生命周期分析"><a href="#Vue-生命周期分析" class="headerlink" title="Vue 生命周期分析"></a>Vue 生命周期分析</h4><p>1) 初始化显示 </p>
<ul>
<li><p>beforeCreate() </p>
</li>
<li><p>created() </p>
</li>
<li><p>beforeMount() *mounted() </p>
</li>
</ul>
<p>2) 更新状态: this.xxx=value </p>
<ul>
<li><p>beforeUpdate() </p>
</li>
<li><p>updated() </p>
</li>
</ul>
<p>3) 销毁 vue 实例: vm.$destory() </p>
<ul>
<li>beforeDestory() </li>
<li>destoryed()</li>
</ul>
<p><strong>常用的生命周期方法</strong></p>
<p>​    1)  created()/<strong>mounted</strong>(): 发送 ajax 请求, 启动定时器等异步任务 </p>
<p>​        Tips: mounted()在html加载完成后执行，vm数据改变会触发mounted（ 不会触发created() ）</p>
<p>​    2)  beforeDestory(): 做收尾工作, 如: 清除定时器</p>
<h3 id="自定义指令-amp-自定义插件"><a href="#自定义指令-amp-自定义插件" class="headerlink" title="自定义指令&amp;自定义插件"></a>自定义指令&amp;自定义插件</h3><h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><p><strong>钩子函数</strong></p>
<ul>
<li><code>bind</code>: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</li>
<li><code>inserted</code>: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li>
<li><code>update</code>: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。</li>
<li><code>componentUpdated</code>: 被绑定元素所在模板完成一次更新周期时调用。</li>
<li><code>unbind</code>: 只调用一次， 指令与元素解绑时调用。</li>
</ul>
<p><strong>钩子函数参数</strong></p>
<ul>
<li><p><strong>el</strong>: 指令所绑定的元素，可以用来直接操作 DOM 。</p>
</li>
<li><p><strong>binding</strong></p>
<p>: 一个对象，包含以下属性：</p>
<ul>
<li><strong>name</strong>: 指令名，不包括 <code>v-</code> 前缀。</li>
<li><strong>value</strong>: 指令的绑定值， 例如： <code>v-my-directive=&quot;1 + 1&quot;</code>, value 的值是 <code>2</code>。</li>
<li><strong>oldValue</strong>: 指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>
<li><strong>expression</strong>: 绑定值的表达式或变量名。 例如 <code>v-my-directive=&quot;1 + 1&quot;</code> ， expression 的值是 <code>&quot;1 + 1&quot;</code>。</li>
<li><strong>arg</strong>: 传给指令的参数。例如 <code>v-my-directive:foo</code>， arg 的值是 <code>&quot;foo&quot;</code>。</li>
<li><strong>modifiers</strong>: 一个包含修饰符的对象。 例如： <code>v-my-directive.foo.bar</code>, 修饰符对象 modifiers 的值是 <code>{ foo: true, bar: true }</code>。</li>
</ul>
</li>
<li><p><strong>vnode</strong>: Vue 编译生成的虚拟节点</p>
</li>
<li><p><strong>oldVnode</strong>: 上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</p>
</li>
</ul>
<p><strong>指令定义与使用</strong></p>
<p>1) 注册全局指令 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'my-directive'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123; 							           		el.innerHTML=binding.value.toupperCase() </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2) 注册局部指令 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">directives:&#123; </span><br><span class="line">    <span class="string">'my-directive'</span>:&#123;</span><br><span class="line">        bind(el,binding)&#123;</span><br><span class="line">            el.innerHTML=binding.value.toupperCase() </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3) 使用指令 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-my-directive</span>=<span class="string">'msg'</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h4><p>1) Vue 插件是一个包含 install 方法的对象</p>
<p>2) 通过 install 方法给 Vue 或 Vue 实例添加方法, 定义全局指令等</p>
<h5 id="定义插件"><a href="#定义插件" class="headerlink" title="定义插件"></a>定义插件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 自 定 义 Vue 插 件</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> MyPlugin = &#123;&#125; </span><br><span class="line">    MyPlugin.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123; </span><br><span class="line">        <span class="comment">// 1. 添 加 全 局 方 法 或 属 性 </span></span><br><span class="line">        Vue.myGlobalMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">            alert(<span class="string">'Vue 函数对象方法执行'</span>) </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 2. 添 加 全 局 资 源 </span></span><br><span class="line">        Vue.directive(<span class="string">'my-directive'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123; </span><br><span class="line">            el.innerHTML = <span class="string">"MyPlugin my-directive "</span> + binding.value </span><br><span class="line">        &#125;) </span><br><span class="line">        <span class="comment">// 3. 添 加 实 例 方 法 </span></span><br><span class="line">        Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">'vue 实例对象方法执行'</span>) </span><br><span class="line">        &#125; &#125;</span><br><span class="line">    <span class="built_in">window</span>.MyPlugin = MyPlugin </span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h5 id="插使用件"><a href="#插使用件" class="headerlink" title="插使用件"></a>插使用件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"demo"</span>&gt; </span><br><span class="line">    &lt;!-使 用 自 定 义 指 令 --&gt; </span><br><span class="line">    &lt;p v-my-directive=<span class="string">"msg"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span> </span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">" src="</span>../js/vue.js<span class="string">"&gt;&lt;/script&gt; </span></span><br><span class="line"><span class="string">&lt;script type="</span>text/javascript<span class="string">" src="</span>vue-myPlugin.js<span class="string">"&gt;&lt;/script&gt; </span></span><br><span class="line"><span class="string">&lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">	// 使 用 自 定 义 插 件 Vue.use(MyPlugin)</span></span><br><span class="line"><span class="string">    var vm = new Vue(&#123; </span></span><br><span class="line"><span class="string">        el: '#demo',</span></span><br><span class="line"><span class="string">        data: &#123; </span></span><br><span class="line"><span class="string">            msg: 'atguigu' </span></span><br><span class="line"><span class="string">        &#125; </span></span><br><span class="line"><span class="string">    &#125;) </span></span><br><span class="line"><span class="string">    // 调 用 自 定 义 的 静 态 方 法 </span></span><br><span class="line"><span class="string">    Vue.myGlobalMethod() </span></span><br><span class="line"><span class="string">    // 调 用 自 定 义 的 对 象 方 法 </span></span><br><span class="line"><span class="string">    vm.$myMethod() </span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Vue组件化编码"><a href="#Vue组件化编码" class="headerlink" title="Vue组件化编码"></a>Vue组件化编码</h2><h3 id="使用-vue-cli-创建模板项目"><a href="#使用-vue-cli-创建模板项目" class="headerlink" title="使用 vue-cli 创建模板项目"></a>使用 vue-cli 创建模板项目</h3><p> vue-cli 是 vue 官方提供的脚手架工具 </p>
<h4 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli //输入项目文件夹名称 VueDemo,项目名称 vue_demo(不能有大写)</span><br><span class="line">vue init webpack vue_demo //使用webpack模板</span><br><span class="line">cd vue_demo //进入vue项目路径（VueDemo）</span><br><span class="line">npm install //安装项目依赖</span><br><span class="line">npm run dev //dev环境启动项目</span><br><span class="line">访问:http://localhost:8080/ //可以修改/config/index.js下的port更改配置</span><br></pre></td></tr></table></figure>

<p>Tips：用WebStorm会无脑很多</p>
<h4 id="模板项目的结构"><a href="#模板项目的结构" class="headerlink" title="模板项目的结构"></a>模板项目的结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|--build:webpack 相关的配置文件夹(基本不需要修改) </span><br><span class="line">	|--dev-server.js: 通过 express 启动后台服务器 </span><br><span class="line">|--config:webpack 相关的配置文件夹(基本不需要修改) </span><br><span class="line">	|--index.js: 指定的后台服务的端口号和静态资源文件夹 </span><br><span class="line">|--node_modules </span><br><span class="line">|--src: 源码文件夹 </span><br><span class="line">	|--components:vue 组件及其相关资源文件夹 </span><br><span class="line">	|--App.vue: 应用根主组件 </span><br><span class="line">	|--main.js: 应用入口 js </span><br><span class="line">|--static: 静态资源文件夹 </span><br><span class="line">|--.babelrc:babel 的配置文件 </span><br><span class="line">|--.eslintignore:eslint 检查忽略的配置 </span><br><span class="line">|--.eslintrc.js:eslint 检查的配置 </span><br><span class="line">|--.gitignore:git 版本管制忽略的配置 </span><br><span class="line">|--index.html: 主页面文件 </span><br><span class="line">|--package.json: 应用包配置文件 </span><br><span class="line">|--README.md: 应用描述说明的 readme 文件</span><br></pre></td></tr></table></figure>

<h4 id="打包发布项目（动态Web服务器tomcat）"><a href="#打包发布项目（动态Web服务器tomcat）" class="headerlink" title="打包发布项目（动态Web服务器tomcat）"></a>打包发布项目（动态Web服务器tomcat）</h4><p>1）修改配置：webpack.prod.conf.js </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output:&#123; </span><br><span class="line">	publicPath:<span class="string">'/myvue/'</span> <span class="comment">//打包文件夹的名称 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）打包：npm run build</p>
<p>3）修改 dist 文件夹为项目名称: myvue</p>
<p>4）将 myvue拷贝到运行的 tomcat 的 webapps 目录下</p>
<p>5）访问:<a href="http://localhost:8080/myvue" target="_blank" rel="noopener">http://localhost:8080/myvue</a></p>
<h4 id="ESlint"><a href="#ESlint" class="headerlink" title="ESlint"></a>ESlint</h4><p>ESLint 是一个代码规范检查工具</p>
<p><strong>修改配置</strong></p>
<p>1) .eslintrc.js: 全局规则配置文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'rules'</span>: &#123;</span><br><span class="line">    <span class="comment">//0：关闭规则。1：打开规则，并且作为一个警告（信息打印黄色字体）。2：打开规则，并且作为一个错误（信息打印红色字体）</span></span><br><span class="line">	<span class="string">'no-new'</span>: <span class="number">1</span> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>2) 在 js/vue 文件中修改局部规则 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*eslint-disable no-new*/</span> </span><br><span class="line">newVue(&#123;</span><br><span class="line">    el: <span class="string">'#body'</span>, </span><br><span class="line">    components: &#123; App &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>3) .eslintignore: 指令检查忽略的文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.js *.vue</span><br></pre></td></tr></table></figure>

<h3 id="组件定义与使用"><a href="#组件定义与使用" class="headerlink" title="组件定义与使用"></a>组件定义与使用</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>1) 引入组件 </p>
<p>2) 映射成标签</p>
<p>3) 使用组件标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--样式--&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    /*样式定义*/</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--模板页面--&gt;</span><br><span class="line">&lt;template&gt; </span><br><span class="line">    &lt;HelloWorld&gt;写法一: 一模一样&lt;/HelloWorld&gt; </span><br><span class="line">    &lt;hello-world&gt;写法二: 大写变小写, 并用-连接&lt;/hello-world&gt; </span><br><span class="line">&lt;/template&gt; </span><br><span class="line"></span><br><span class="line">&lt;!--JS 模块对象--&gt;</span><br><span class="line">&lt;script&gt; </span><br><span class="line">    import HelloWorld from &apos;./components/HelloWorld&apos; </span><br><span class="line">    export default&#123;</span><br><span class="line">        components:&#123;</span><br><span class="line">            HelloWorld // HelloWorld：HelloWorld简写</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h4><h5 id="组件间通信基本原则"><a href="#组件间通信基本原则" class="headerlink" title="组件间通信基本原则"></a>组件间通信基本原则</h5><p>1)  不要在子组件中直接修改父组件的状态数据 </p>
<p>2)  数据在哪, 更新数据的行为(函数)就应该定义在哪</p>
<h5 id="Vue-组件间通信方式"><a href="#Vue-组件间通信方式" class="headerlink" title="Vue 组件间通信方式"></a>Vue 组件间通信方式</h5><h6 id="1-props"><a href="#1-props" class="headerlink" title="1) props"></a>1) props</h6><p>​    1）使用组件标签时</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">name</span>=<span class="string">'tom'</span> <span class="attr">:age</span>=<span class="string">'3'</span> <span class="attr">:set-name</span>=<span class="string">'setName'</span>&gt;</span> <span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    2）定义 MyComponent 时，在组件内声明所有的 props </p>
<p>​        方式一: 只指定名称 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props:[&apos;name&apos;, &apos;age&apos;,&apos; setName&apos;]</span><br></pre></td></tr></table></figure>

<p>​         方式二: 指定名称和类型 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props:&#123; name: String, age: Number, setNmae: Function &#125;</span><br></pre></td></tr></table></figure>

<p>​        方式三: 指定名称/类型/必要性/默认值 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props:&#123; name:&#123;type: String, required: true, default: xxx&#125;, &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<p>1) 此方式用于父组件向子组件传递数据 </p>
<p>2) 所有标签属性都会成为组件对象的属性, 模板页面可以直接引用 </p>
<p><strong>3) 问题:</strong> </p>
<p>a. 如果需要向非子后代传递数据必须多层逐层传递 </p>
<p>b. 兄弟组件间也不能直接 props 通信, 必须借助父组件才可以</p>
<h6 id="2-vue-的自定义事件"><a href="#2-vue-的自定义事件" class="headerlink" title="2) vue 的自定义事件"></a>2) vue 的自定义事件</h6><h6 id="3-消息订阅与发布-如-pubsub-库"><a href="#3-消息订阅与发布-如-pubsub-库" class="headerlink" title="3) 消息订阅与发布(如:pubsub 库)"></a>3) 消息订阅与发布(如:pubsub 库)</h6><p>​    1）绑定事件监听（订阅消息）</p>
<p>​        目标：标签元素 &lt;button&gt; </p>
<p>​        事件名(类型)：click/focus </p>
<p>​        回调函数：function(event){}    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PubSub.subscribe(<span class="string">'msg'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg,data</span>)</span>&#123; ... &#125;  )	<span class="comment">//msg没什么用处，但必须是第一个参数</span></span><br></pre></td></tr></table></figure>

<p>​    2）触发事件（发布消息）</p>
<p>​        DOM 事件：用户在浏览器上对应的界面上做对应的操作 </p>
<p>​        自定义：编码手动触发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PubSub.publish(<span class="string">'msg'</span>,data)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>优点： 此方式可实现任意关系组件间通信(数据)</p>
<h6 id="4-slot"><a href="#4-slot" class="headerlink" title="4) slot"></a>4) slot</h6><p>此方式用于父组件向子组件传递<code>标签数据</code>（常用于多个父组件用一个子组件但子组件略有变化的情况）</p>
<p>​    1）子组件:Child.vue</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"xxx"</span>&gt;</span>不确定的标签结构 1<span class="tag">&lt;/<span class="name">slot</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>组件确定的标签结构<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"yyy"</span>&gt;</span>不确定的标签结构 2<span class="tag">&lt;/<span class="name">slot</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    2）父组件:Parent.vue</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">"xxx"</span>&gt;</span>xxx 对应的标签结构<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">"yyy"</span>&gt;</span>yyyy 对应的标签结构<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="5-vuex-后面单独讲"><a href="#5-vuex-后面单独讲" class="headerlink" title="5) vuex(后面单独讲)"></a>5) vuex(后面单独讲)</h6><h2 id="Vue-ajax"><a href="#Vue-ajax" class="headerlink" title="Vue-ajax"></a>Vue-ajax</h2><h3 id="vue-resource"><a href="#vue-resource" class="headerlink" title="vue-resource"></a>vue-resource</h3><h3 id="axios-推荐"><a href="#axios-推荐" class="headerlink" title="axios(推荐)"></a>axios(推荐)</h3><p>1） 下载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save axios</span><br></pre></td></tr></table></figure>

<p>2） 编码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入模块 </span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="comment">// 发送 ajax 请求 </span></span><br><span class="line">axios.get(url).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(response.data)</span><br><span class="line">    <span class="comment">// 得到返回结果数据 </span></span><br><span class="line">	&#125;) .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log( error.message) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h4><p>可以通过向 axios 传递相关配置来创建请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">axios(config)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 POST 请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  GET 请求远程图片</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method:<span class="string">'get'</span>,</span><br><span class="line">  url:<span class="string">'http://bit.ly/2mTM3nY'</span>,</span><br><span class="line">  responseType:<span class="string">'stream'</span></span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  response.data.pipe(fs.createWriteStream(<span class="string">'ada_lovelace.jpg'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios(url[, config])</span><br><span class="line"><span class="comment">// 发送 GET 请求（默认的方法）</span></span><br><span class="line">axios(<span class="string">'/user/12345'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="请求方法的别名"><a href="#请求方法的别名" class="headerlink" title="请求方法的别名"></a>请求方法的别名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.request(config)</span><br><span class="line">axios.get(url[, config])</span><br><span class="line">axios.delete(url[, config])</span><br><span class="line">axios.head(url[, config])</span><br><span class="line">axios.post(url[, data[, config]])</span><br><span class="line">axios.put(url[, data[, config]])</span><br><span class="line">axios.patch(url[, data[, config]])</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</p>
<h4 id="执行多个并发请求"><a href="#执行多个并发请求" class="headerlink" title="执行多个并发请求"></a>执行多个并发请求</h4><p>处理并发请求的助手函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.all(iterable)</span><br><span class="line">axios.spread(callback)</span><br></pre></td></tr></table></figure>

<p><strong>应用实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345/permissions'</span>);</span><br><span class="line">&#125;</span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct, perms</span>) </span>&#123;	<span class="comment">//第1、2个返回结果 </span></span><br><span class="line">    <span class="comment">// 两个请求现在都执行完成</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure>

<h4 id="创建实例（拦截器、配置默认值）"><a href="#创建实例（拦截器、配置默认值）" class="headerlink" title="创建实例（拦截器、配置默认值）"></a>创建实例（拦截器、配置默认值）</h4><p>可以使用自定义配置新建一个 axios 实例：/utils/request.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Message <span class="comment">/* MessageBox*/</span> &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../store'</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken &#125; <span class="keyword">from</span> <span class="string">'@/utils/auth'</span></span><br><span class="line"></span><br><span class="line">axios.create([config])</span><br><span class="line"><span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">    baseURL: process.env.BASE_API, <span class="comment">// api 的 base_url</span></span><br><span class="line">    timeout: <span class="number">15000</span>, <span class="comment">// 请求超时时间</span></span><br><span class="line">    withCredentials: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对axios实例继续配置，修改默认值</span></span><br><span class="line">service.defaults.withCredentials = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// request拦截器</span></span><br><span class="line">service.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    config.headers[<span class="string">'Access-Control-Allow-Origin'</span>] = <span class="built_in">window</span>.location.host</span><br><span class="line">    <span class="keyword">if</span> (store.getters.token) &#123;</span><br><span class="line">      <span class="comment">// 让每个请求携带自定义token 请根据实际情况自行修改</span></span><br><span class="line">      config.headers[<span class="string">'X-Token'</span>] = getToken() </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="comment">// Do something with request error</span></span><br><span class="line">    <span class="built_in">console</span>.log(error) <span class="comment">// for debug</span></span><br><span class="line">    <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// response 拦截器</span></span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">  response =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> response.data</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err'</span> + error) <span class="comment">// for debug</span></span><br><span class="line">    Message(&#123;</span><br><span class="line">      message: error.message,</span><br><span class="line">      type: <span class="string">'error'</span>,</span><br><span class="line">      duration: <span class="number">5</span> * <span class="number">1000</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//向外暴露实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service</span><br></pre></td></tr></table></figure>

<h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'@/utils/request'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用request实例，向外暴露多个函数供其他组件调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fileUpload</span>(<span class="params">file, mappings</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//form表单方式提交</span></span><br><span class="line">  <span class="keyword">var</span> bodyFormData = <span class="keyword">new</span> FormData();</span><br><span class="line">  bodyFormData.append(<span class="string">'file'</span>,file);</span><br><span class="line">  bodyFormData.append(<span class="string">'mappings'</span>,mappings);</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    url: <span class="string">'/transport/v1/fileUpload'</span>,</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    data: bodyFormData,</span><br><span class="line">    config: &#123; <span class="attr">headers</span>: &#123;<span class="string">'Content-Type'</span>: <span class="string">'multipart/form-data'</span> &#125;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addStream</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="VueUI-组件库"><a href="#VueUI-组件库" class="headerlink" title="VueUI 组件库"></a>VueUI 组件库</h2><p>1)  MintUI: </p>
<p>​    a. 主页:<a href="http://mint-ui.github.io/#!/zh-cn" target="_blank" rel="noopener">http://mint-ui.github.io/#!/zh-cn</a> </p>
<p>​    b. 说明: 饿了么开源的基于 vue 的移动端 UI 组件库 </p>
<p>2)  Elment </p>
<p>​    a. 主页:<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN</a> </p>
<p>​    b. 说明: 饿了么开源的基于 vue 的 PC 端 UI 组件库</p>
<p><strong>下载</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-ui -S  // 等同npm install element-ui --save</span><br></pre></td></tr></table></figure>

<h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p><a href="https://element.eleme.cn/#/zh-CN/component/quickstart" target="_blank" rel="noopener">ElementUI快速入手参考文档</a></p>
<h4 id="引入-Element"><a href="#引入-Element" class="headerlink" title="引入 Element"></a>引入 Element</h4><h5 id="完整引入"><a href="#完整引入" class="headerlink" title="完整引入"></a>完整引入</h5><p>在 main.js 中写入以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。</p>
<h5 id="按需引入"><a href="#按需引入" class="headerlink" title="按需引入"></a>按需引入</h5><p>借助 <a href="https://github.com/QingWei-Li/babel-plugin-component" target="_blank" rel="noopener">babel-plugin-component</a>，我们可以只引入需要的组件，以达到减小项目体积的目的。</p>
<p>首先，安装 babel-plugin-component：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure>

<p>然后，将 .babelrc 修改为：在plugins后新增[,”component”,…]内容</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [ <span class="string">"xxx"</span>, ... ,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"component"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"libraryName"</span>: <span class="string">"element-ui"</span>,</span><br><span class="line">        <span class="attr">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，如果你只希望引入部分组件，比如 Button 和 Select，那么需要在 main.js 中写入以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Select &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"></span><br><span class="line">Vue.component(Button.name, Button);</span><br><span class="line">Vue.component(Select.name, Select);</span><br><span class="line"><span class="comment">/* 或写为</span></span><br><span class="line"><span class="comment"> * Vue.use(Button)</span></span><br><span class="line"><span class="comment"> * Vue.use(Select)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="使用el标签"><a href="#使用el标签" class="headerlink" title="使用el标签"></a>使用el标签</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">icon</span>=<span class="string">"el-icon-search"</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h2><p>官方提供的用来实现 SPA 的 vue 插件</p>
<p>下载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue -router --save</span><br></pre></td></tr></table></figure>

<h3 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h3><ul>
<li>路由组件：Home.vue、About.vue</li>
</ul>
<ul>
<li>路由器模块：src/router/index.js     </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;<span class="comment">// VueRouter() 用于创建路由器的构建函数</span></span><br><span class="line">    routes:[ </span><br><span class="line">        &#123;<span class="comment">// 一般路由 </span></span><br><span class="line">            path:<span class="string">'/about'</span>, </span><br><span class="line">            component: About <span class="comment">// view文件夹下有About.vue路由组件</span></span><br><span class="line">        &#125;, &#123;<span class="comment">// 自动跳转路由 </span></span><br><span class="line">            path:<span class="string">'/'</span>, </span><br><span class="line">            redirect:<span class="string">'/about'</span> </span><br><span class="line">        &#125; </span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>注册路由器：main.js</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span> <span class="comment">// 简写./router/index.js</span></span><br><span class="line">newVue(&#123; </span><br><span class="line">    router <span class="comment">// 简写 router: router</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用路由组件标签</p>
<ol>
<li><router-link>: 用来生成路由链接 </router-link></li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/home"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><router-view>: 用来显示当前路由组件界面 </router-view></li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="子路由组件"><a href="#子路由组件" class="headerlink" title="子路由组件"></a>子路由组件</h3><ul>
<li><p>子路由组件：  News.vue、 Message.vue</p>
</li>
<li><p>配置嵌套路由：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">routes:[&#123;</span><br><span class="line">    path:<span class="string">'/home'</span>, </span><br><span class="line">    component:home, </span><br><span class="line">    children:[ &#123; </span><br><span class="line">            path:<span class="string">'/home/news'</span>, </span><br><span class="line">            component:News </span><br><span class="line">        &#125;, &#123; </span><br><span class="line">            path:<span class="string">'message'</span>, <span class="comment">//相对路径</span></span><br><span class="line">            component:Message </span><br><span class="line">        &#125; </span><br><span class="line">    ]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<ul>
<li>路由链接:  Home.vue组件下</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/home/news"</span>&gt;</span>News<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/home/message"</span>&gt;</span>Message<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">route-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="向路由组件传递数据"><a href="#向路由组件传递数据" class="headerlink" title="向路由组件传递数据"></a>向路由组件传递数据</h3><h4 id="路由路径携带参数-param-query"><a href="#路由路径携带参数-param-query" class="headerlink" title="路由路径携带参数(param/query)"></a>路由路径携带参数(param/query)</h4><ul>
<li>配置路由  /home/news下的子路由</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">children:[ &#123; </span><br><span class="line">    path:<span class="string">'mdetail/:id'</span>, </span><br><span class="line">    <span class="comment">// path: 'mdetail/’，query方式</span></span><br><span class="line">    component:MessageDetail </span><br><span class="line">&#125; ]</span><br></pre></td></tr></table></figure>

<ul>
<li>路由路径 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--param方式--&gt;</span><br><span class="line">&lt;router-link :to=<span class="string">"'/home/message/mdetail/'+m.id"</span>&gt;&#123;&#123;m.title&#125;&#125;&lt;<span class="regexp">/router-link&gt; </span></span><br><span class="line"><span class="regexp">&lt;!--query方式--&gt;</span></span><br><span class="line"><span class="regexp">&lt;router-link :to="`/</span>home/message/mdetail/?id=$&#123;m.id&#125;<span class="string">`"&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>子路由组件中读取请求参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$route.params.id</span><br></pre></td></tr></table></figure>

<p><strong>Tips</strong> ：如果路由数据处理逻辑定义在mounted里，因为页面加载一次，没有数据改变，不会触发mounted逻辑</p>
<p><strong>解决办法</strong>：监听route属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="comment">//注意！！！ 这里不在data里定义属性，直接赋值其他地方调用this里属性</span></span><br><span class="line">    <span class="keyword">const</span> allMessageDetail = [ &#123;<span class="attr">id</span>: <span class="number">1</span>, ...&#125;, &#123;...&#125;, ...]</span><br><span class="line">    <span class="keyword">this</span>.allMessageDetail = allMessageDetail</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    $route: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;	<span class="comment">//路由路径发生了变化</span></span><br><span class="line">        <span class="keyword">const</span> id = value.params.id*<span class="number">1</span>	<span class="comment">//路径传递的是String，detail.id是Number</span></span><br><span class="line">        <span class="keyword">this</span>.messageDetail = <span class="keyword">this</span>.allMessageDetail.find(<span class="function"><span class="params">detail</span> =&gt;</span> detai.id === id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lt-router-view-gt-属性携带数据"><a href="#lt-router-view-gt-属性携带数据" class="headerlink" title="&lt;router-view&gt;属性携带数据"></a>&lt;router-view&gt;属性携带数据</h4><ul>
<li>父组件标签携带数据</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">:msg</span>=<span class="string">"msg"</span>&gt;</span> <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>子路由中Vue属性配置props</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: &#123; <span class="attr">msg</span>:<span class="built_in">String</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓存路由组件对象"><a href="#缓存路由组件对象" class="headerlink" title="缓存路由组件对象"></a>缓存路由组件对象</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h4><p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=<span class="string">"pushShow(m.id)"</span>&gt;push查看&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">methods: &#123;</span></span><br><span class="line"><span class="regexp">    pushShow(id)&#123;</span></span><br><span class="line"><span class="regexp">        this.$router.push(`/</span>home/message/mdetail/?id=$&#123;id&#125;<span class="string">`)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>1) this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面) </p>
<p>2) this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面) </p>
<p>3) this.$router.back(): 请求(返回)上一个记录路由 </p>
<p>4) this.$router.go(-1): 请求(返回)上一个记录路由 </p>
<p>5) this.$router.go(1): 请求下一个记录路</p>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h2 id="Vue源码分析"><a href="#Vue源码分析" class="headerlink" title="Vue源码分析"></a>Vue源码分析</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/03/面试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cilibili">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/03/面试/" itemprop="url">面试问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-03T16:07:20+08:00">
                2019-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><h2 id="爱奇艺"><a href="#爱奇艺" class="headerlink" title="爱奇艺"></a>爱奇艺</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>（19/7/30）</p>
<h4 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h4><h4 id="事务特性，Spring-事务传播"><a href="#事务特性，Spring-事务传播" class="headerlink" title="事务特性，Spring 事务传播"></a>事务特性，Spring 事务传播</h4><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><h4 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h4><h4 id="AOP，IOC"><a href="#AOP，IOC" class="headerlink" title="AOP，IOC"></a>AOP，IOC</h4><h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h4><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h4 id="Synchronized-和lock区别"><a href="#Synchronized-和lock区别" class="headerlink" title="Synchronized 和lock区别"></a>Synchronized 和lock区别</h4><p>（这一点啊！！！才总结的啊！！！居然只回答了说Lock读写高效，可中断。）</p>
<h4 id="分布式同步机制"><a href="#分布式同步机制" class="headerlink" title="分布式同步机制"></a>分布式同步机制</h4><h4 id="Http发请求过程"><a href="#Http发请求过程" class="headerlink" title="Http发请求过程"></a>Http发请求过程</h4><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>（19/8/2）</p>
<h4 id="项目-1"><a href="#项目-1" class="headerlink" title="项目"></a>项目</h4><h4 id="springboot-创建项目过程，请求调用过程"><a href="#springboot-创建项目过程，请求调用过程" class="headerlink" title="springboot 创建项目过程，请求调用过程"></a>springboot 创建项目过程，请求调用过程</h4><h4 id="controller、filter、interceptor、service调用关系"><a href="#controller、filter、interceptor、service调用关系" class="headerlink" title="controller、filter、interceptor、service调用关系"></a>controller、filter、interceptor、service调用关系</h4><h4 id="equals-和"><a href="#equals-和" class="headerlink" title="equals 和 =="></a>equals 和 ==</h4><h4 id="了解的几种线程池"><a href="#了解的几种线程池" class="headerlink" title="了解的几种线程池"></a>了解的几种线程池</h4><h4 id="对象在什么时候回收"><a href="#对象在什么时候回收" class="headerlink" title="对象在什么时候回收"></a>对象在什么时候回收</h4><h4 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h4><h4 id="3个字段的联合主键，只查询两个字段，利用索引了吗"><a href="#3个字段的联合主键，只查询两个字段，利用索引了吗" class="headerlink" title="3个字段的联合主键，只查询两个字段，利用索引了吗"></a>3个字段的联合主键，只查询两个字段，利用索引了吗</h4><h4 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h4><p>聚合函数、嵌套select语句等。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/30/JAVA并发编程学习总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cilibili">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/30/JAVA并发编程学习总结/" itemprop="url">JAVA并发编程学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-30T10:07:20+08:00">
                2019-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JAVA-并发编程"><a href="#JAVA-并发编程" class="headerlink" title="JAVA 并发编程"></a>JAVA 并发编程</h1><h2 id="JUC-简介"><a href="#JUC-简介" class="headerlink" title="JUC 简介"></a>JUC 简介</h2><p>在 Java 5.0 提供了 java.util.concurrent （简称 JUC ）包，在此包中增加了在并发编程中很常用 的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。提供可调的、灵活的线程池。还提供了设计用于多线程上下文中的 Collection 实现等。</p>
<h3 id="常用线程方法"><a href="#常用线程方法" class="headerlink" title="常用线程方法"></a>常用线程方法</h3><p><a href="https://blog.csdn.net/vbirdbest/article/details/81282163" target="_blank" rel="noopener">参考博客</a></p>
<ul>
<li><p><strong>sleep() 与 interrupt()</strong>：sleep(long millis): 睡眠指定时间，程序暂停运行，睡眠期间会让出CPU的执行权，去执行其它线程，同时CPU也会监视睡眠的时间，一旦睡眠时间到就会立刻执行(因为睡眠过程中仍然保留着锁，有锁只要睡眠时间到就能立刻执行)。</p>
<ul>
<li><p>sleep(): 睡眠指定时间，即让程序暂停指定时间运行，时间到了会继续执行代码，如果时间未到就要醒需要使用interrupt()来随时唤醒</p>
</li>
<li><p>interrupt(): 唤醒正在睡眠的程序，调用interrupt()方法，会使得sleep()方法抛出InterruptedException异常，当sleep()方法抛出异常就中断了sleep的方法，从而让程序继续运行下去</p>
</li>
</ul>
</li>
<li><p><strong>wait() 与 notify()</strong>：wait、notify和notifyAll方法是Object类的final native方法。所以这些方法不能被子类重写，Object类是所有类的超类，因此在程序中可以通过this或者super来调用this.wait(), super.wait()</p>
<ul>
<li><p>wait(): 导致线程进入等待阻塞状态，会一直等待直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在同步方法中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。wait(long timeout): 时间到了自动执行，类似于sleep(long millis)</p>
</li>
<li><p>notify(): 该方法只能在同步方法或同步块内部调用， 随机选择一个(注意：只会通知一个)<strong>在该对象上</strong>调用wait方法的线程，解除其阻塞状态</p>
</li>
<li><p>notifyAll(): 唤醒所有的wait对象</p>
<p><strong>注意！</strong></p>
<ul>
<li>Object.wait()和Object.notify()和Object.notifyall()必须写在synchronized方法内部或者synchronized块内部</li>
<li>让哪个对象等待wait就去通知notify哪个对象，不要让A对象等待，结果却去通知B对象，要操作同一个对象</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>sleep() 与 wait()</strong>： Thread.sleep(long millis): 睡眠时不会释放锁</p>
</li>
<li><p><strong>wait() 与 interrupt()</strong>：wait(): 方法的作用是释放锁，加入到等待队列，当调用interrupt()方法后，线程必须先获<strong>取到锁后</strong>，然后才抛出异常InterruptedException 。注意： 在获取锁之前是不会抛出异常的，只有在获取锁之后才会抛异常</p>
<ul>
<li>tips：所有能抛出InterruptedException的方法都可以通过interrupt()来取消的（如sleep()，yield()，wait() ）</li>
</ul>
</li>
<li><p><strong>notify()和interrupt()</strong>： 从让正在wait的线程重新运行这一点来说，notify方法和interrupt方法的作用有些类似，但仍有以下不同之处：</p>
<ul>
<li>notify/notifyAll是java.lang.Object类的方法，唤醒的是该实例的等待队列中的线程，而不能直接指定某个具体的线程。notify/notifyAll唤醒的线程会继续执行wait的下一条语句，另外执行notify/notifyAll时线程必须要获取实例的锁</li>
<li>interrupte方法是java.lang.Thread类的方法，可以直接指定线程并唤醒，当被interrupt的线程处于sleep或者wait中时会抛出InterruptedException异常。执行interrupt()并不需要获取取消线程的锁。</li>
</ul>
</li>
<li><p><strong>join()</strong>： 让当前线程加入父线程，加入后父线程会一直wait，直到子线程执行完毕后父线程才能执行。当我们调用某个线程的这个方法时，这个方法会挂起调用线程，直到被调用线程结束执行，调用线程才会继续执行。</p>
<ul>
<li>将某个线程加入到当前线程中来，一般某个线程和当前线程依赖关系比较强，必须先等待某个线程执行完毕才能执行当前线程。一般在run()方法内使用</li>
<li>在Parent调用child.join()后，child子线程正常运行，Parent父线程会等待child子线程结束后再继续运行</li>
</ul>
</li>
<li><p><strong>yield()</strong>： 交出CPU的执行时间，不会释放锁，让线程进入就绪状态，等待重新获取CPU执行时间，yield就像一个好人似的，当CPU轮到它了，它却说我先不急，先给其他线程执行吧, 此方法很少被使用到</p>
</li>
<li><p><strong>setDaemon(boolean on)</strong>： 线程分两种：</p>
<ul>
<li>用户线程：如果主线程main停止掉，不会影响用户线程，用户线程可以继续运行。</li>
<li>守护线程：如果主线程死亡，守护线程如果没有执行完毕也要跟着一块死，GC垃圾回收线程就是守护线程</li>
</ul>
</li>
</ul>
<h2 id="volatile关键字-内存可见性"><a href="#volatile关键字-内存可见性" class="headerlink" title="volatile关键字 - 内存可见性"></a>volatile关键字 - 内存可见性</h2><p><strong>内存可见性</strong>（Memory Visibility）</p>
<p>是指当某个线程正在使用对象状态 而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p>
<p><strong>可见性错误</strong></p>
<p>是指当读操作与写操作在不同的线程中执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情</p>
<p><strong>volatile</strong>关键字</p>
<p>利用操作系统的内存栅栏实现，用来确保将变量的更新操作通知到其他线程。可以将 volatile 看做一个轻量级的锁，但是又与 锁有些不同：</p>
<ul>
<li>对于多线程，不是一种互斥关系</li>
<li>不能保证变量状态的“原子性操作</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程ThreadDemo修改flag的值，main线程在读取flag的值，在volatile修饰之前，线程ThreadDemo修改flag的值不会立即在内存中修改，使用volatile修饰flag之后，保证了内存的可见性（相当于直接在主存中修改共享变量的值。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">		<span class="keyword">new</span> Thread(td).start();</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// td.flag在main线程和ThreadDemo线程中共享</span></span><br><span class="line">            <span class="comment">// 同一个对象的成员变量，main在读，ThreadDemo在改</span></span><br><span class="line">			<span class="keyword">if</span>(td.isFlag())&#123;</span><br><span class="line">				System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadDemo线程持有有状态的成员变量flag，并且会修改flag的值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		flag = <span class="keyword">true</span>;</span><br><span class="line">		System.out.println(<span class="string">"flag="</span> + isFlag());</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> flag;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flag = flag;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子变量-CAS算法"><a href="#原子变量-CAS算法" class="headerlink" title="原子变量-CAS算法"></a>原子变量-CAS算法</h2><h3 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h3><p>是一种硬件对并发的支持，针对多处理器 操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并<br>发访问。</p>
<ul>
<li><p>CAS 是一种无锁的非阻塞算法的实现。</p>
</li>
<li><p>CAS 包含了 3 个操作数：</p>
<ul>
<li><p>需要读写的内存值 V</p>
</li>
<li><p>进行比较的值 A</p>
</li>
<li><p>拟写入的新值 B</p>
<p>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的 值，否则不会执行任何操作</p>
</li>
</ul>
</li>
</ul>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 模拟 CAS 算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompareAndSwap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> CompareAndSwap cas = <span class="keyword">new</span> CompareAndSwap();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                </span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 第一次获取共享变量值</span></span><br><span class="line">					<span class="keyword">int</span> expectedValue = cas.get();</span><br><span class="line">					cas.compareAndSet(expectedValue, (<span class="keyword">int</span>)(Math.random() * <span class="number">101</span>));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareAndSwap</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 获取内存值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 比较</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 第二次获取共享变量值，进行比较</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.value == expectedValue)&#123;</span><br><span class="line">			<span class="keyword">this</span>.value = newValue;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">        <span class="comment">// compareAndSwap是compareAndSet具体的实现</span></span><br><span class="line">		<span class="keyword">return</span> compareAndSwap(expectedValue, newValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h3><ul>
<li><p>类的小工具包，支持在单个变量上解除锁的线程安全编程。事实上，此包中的类可将 volatile 值、字段和数组元素的概念扩展到那些也提供原子条件更新操作的类。</p>
</li>
<li><p><strong>java.util.concurrent.atomic</strong> 包下提供了一些原子操作的常用类: </p>
<ul>
<li>AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReference </li>
<li>AtomicIntegerArray 、AtomicLongArray </li>
<li>AtomicMarkableReference </li>
<li>AtomicReferenceArray </li>
<li>AtomicStampedReference</li>
</ul>
</li>
<li><p>类 AtomicBoolean、AtomicInteger、AtomicLong 和 AtomicReference 的实例各自提供对 相应类型单个变量的访问和更新。每个类也为该类型提供适当的实用工具方法。</p>
</li>
<li><p>AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray 类进一步扩展了原子操 作，对这些类型的数组提供了支持。这些类在为其数组元素提供 volatile 访问语义方 面也引人注目，这对于普通数组来说是不受支持的</p>
</li>
<li><p><strong>核心方法：boolean compareAndSet(expectedValue, updateValue)</strong></p>
</li>
</ul>
<h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomicDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AtomicDemo ad = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(ad).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：Atomic只能保证原子性，不能保证可见性。如果用volatile修饰Atomic变量，就能保证对有状态变量的多线程安全操作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="comment">// private volatile int serialNumber = 0; 不能保证原子性，因为i++操作是分三步完成</span></span><br><span class="line">	<span class="keyword">private</span> AtomicInteger serialNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(getSerialNumber());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSerialNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> serialNumber.getAndIncrement();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h2><h3 id="ConcurrentHashMap-锁分段机制"><a href="#ConcurrentHashMap-锁分段机制" class="headerlink" title="ConcurrentHashMap 锁分段机制"></a>ConcurrentHashMap 锁分段机制</h3><ul>
<li><p>ConcurrentHashMap 同步容器类是Java 5 增加的一个线程安全的哈希表。对 与多线程的操作，介于 HashMap 与 Hashtable 之间。内部采用“锁分段” 机制替代 Hashtable 的独占锁。进而提高性能。</p>
</li>
<li><p>*<em>HashTable效率底原因 *</em>：Hashtable之所以效率低下主要是因为其实现使用了synchronized关键字对put等操作进行加锁，而synchronized关键字加锁是对整个对象进行加锁，也就是说在进行put等修改Hash表的操作时，锁住了整个Hash表，从而使得其表现的效率低下</p>
</li>
</ul>
<h4 id="JDK1-7机制"><a href="#JDK1-7机制" class="headerlink" title="JDK1.7机制"></a>JDK1.7机制</h4><p><a href="https://blog.csdn.net/bill_xiang_/article/details/81122044#1.1%20%E5%88%86%E6%AE%B5%E9%94%81%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">参考博客</a></p>
<p><strong>ConcurrentHashMap实现原理(JDK 1.7)</strong>：在ConcurrentHashMap中，定义了一个Segment&lt;K, V&gt;[]数组（桶）来将Hash表实现<strong>分段存储</strong>，从而实现分段加锁；而么一个Segment元素则与HashMap结构类似，其包含了一个HashEntry链表（节点），用来存储Key/Value对。Segment继承了ReetrantLock，表示Segment是一个可重入锁，因此ConcurrentHashMap通过可重入锁对每个分段进行加锁。</p>
<ul>
<li>初始化：通过位与运算来初始化Segment的大小，所以Segment的大小取值都是以2的N次方扩充</li>
<li>put操作：Segment实现了ReentrantLock,也就带有锁的功能。当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值。然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，通过继承ReentrantLock的tryLock（）方法尝试去获取锁，在将数据插入指定的HashEntry位置时（链表的尾端）。</li>
<li>get操作：第一次hash定位到Segment的位置，然后再hash定位到指定的HashEntry，遍历该HashEntry下的链表进行对比，成功就返回，不成功就返回null。</li>
<li>size操作：多次计算ConcurrentHashMap的size比较；给每个Segment加上锁。</li>
</ul>
<h4 id="JDK1-8机制"><a href="#JDK1-8机制" class="headerlink" title="JDK1.8机制"></a>JDK1.8机制</h4><p><a href="https://blog.csdn.net/qq296398300/article/details/79074239" target="_blank" rel="noopener">参考博客</a></p>
<p>JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本。</p>
<ul>
<li><p>结构：</p>
<ol>
<li>Node：是ConcurrentHashMap存储结构的基本单元，继承HashMap.Entry，用于存储数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Node就是一个链表，但是只允许对数据进行查找，不允许进行修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key; <span class="comment">//key是final类型，不允许修改数据</span></span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>TreeNode：继承与Node，但是数据结构换成了二叉树结构，它是红黑树的数据的存储结构，用于红黑树中存储数据，当链表的节点数大于8时会转换成红黑树的结构，他就是通过TreeNode作为存储结构代替Node来转换成黑红树</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red; <span class="comment">//标注红黑树的红节点</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>TreeBin：从字面含义中可以理解为存储树形结构的容器，而树形结构就是指TreeNode，所以TreeBin就是封装TreeNode的容器，它提供转换黑红树的一些条件和锁的控制</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">    <span class="comment">// values for lockState</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// 获取写锁的状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// 等待写锁的状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// 增加数据时读锁的状态</span></span><br><span class="line">    </span><br><span class="line">    TreeBin(TreeNode&lt;K,V&gt; b) &#123; <span class="comment">// 初始化红黑树</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>put操作：对当前的Node&lt;K,V&gt;[] table进行无条件自循环直到put成功，可以分成以下六步流程来概述 </p>
<ol>
<li><p>如果table没有初始化（为null或长度为0）就先调用initTable（）方法来进行初始化过程</p>
</li>
<li><p>如果没有hash冲突就直接CAS插入</p>
</li>
<li><p>如果还在进行扩容操作就先进行扩容</p>
</li>
<li><p>如果存在hash冲突，就加锁（synchronized）来保证线程安全。这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入。如果涉及到相同的key，进行put就会覆盖原先的value</p>
</li>
<li><p>最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环</p>
</li>
<li><p>如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容</p>
<p>tips：jdk1.8中put操作在并发处理中使用的是乐观锁，当有冲突的时候才进行并发处理</p>
</li>
</ol>
</li>
<li><p>get操作：</p>
<ol>
<li>计算hash值，定位到该table索引位置，如果是首节点符合就返回</li>
<li>如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回</li>
<li>以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null</li>
</ol>
</li>
<li><p>size操作：</p>
<ol>
<li>JDK1.8 对于size的计算，在扩容和addCount()方法就已经有处理了，JDK1.7是在调用size()方法才去计算</li>
</ol>
</li>
</ul>
<h4 id="JDK1-7与1-8差异总结"><a href="#JDK1-7与1-8差异总结" class="headerlink" title="JDK1.7与1.8差异总结"></a>JDK1.7与1.8差异总结</h4><ul>
<li>从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树,相对而言，总结如下思考<ol>
<li>JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点）</li>
<li>JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了</li>
<li>JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档</li>
</ol>
</li>
</ul>
<p><a href="https://blog.csdn.net/qq296398300/article/details/79074239" target="_blank" rel="noopener">ConcurrentHashMap摘自博客</a></p>
<h3 id="CopyOnWriteArrayList等其他同步容器"><a href="#CopyOnWriteArrayList等其他同步容器" class="headerlink" title="CopyOnWriteArrayList等其他同步容器"></a>CopyOnWriteArrayList等其他同步容器</h3><ul>
<li><strong>其他同步容器： *<em>java.util.concurrent包下还提供了设计用于多线程上下文中的 Collection 实现： *</em>ConcurrentHashMap</strong>、<strong>ConcurrentSkipListMap</strong>（底层是通过跳表来实现）、<strong>ConcurrentSkipListSet</strong>、 <strong>CopyOnWriteArrayList</strong> 和 <strong>CopyOnWriteArraySet</strong>。当期望许多线程访问一个给 定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap， ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远 大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。        总结：读比写操作多时，concurrent下面的方法性能更好。</li>
</ul>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CopyOnWriteArrayList/CopyOnWriteArraySet : “写入并复制”</span></span><br><span class="line"><span class="comment"> * 注意：添加操作多时，效率低，因为每次添加时都会进行复制，开销非常的大。并发迭代操作多时可以选择。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCopyOnWriteArrayList</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HelloThread ht = <span class="keyword">new</span> HelloThread();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(ht,<span class="string">"线程"</span>+i).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="comment">// 在对同一个数组遍历同时修改的话会报错：java.util.ConcurrentModificationException</span></span><br><span class="line">	<span class="comment">// private static List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;String&gt;());</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		list.add(<span class="string">"AA"</span>);</span><br><span class="line">		list.add(<span class="string">"BB"</span>);</span><br><span class="line">		list.add(<span class="string">"CC"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			list.add(<span class="string">"AA"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch 闭锁"></a>CountDownLatch 闭锁</h2><ul>
<li><strong>CountDownLatch：</strong> 一个同步辅助类，在完成一组正在其他线程中执行的操作 之前，它允许一个或多个线程一直等待。闭锁可以延迟线程的进度直到其到达终止状态，闭锁可以用来确保某些活动直到其他活动都完成才继续执行：<ul>
<li>确保某个计算在其需要的所有资源都被初始化之后才继续执行;</li>
<li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动;</li>
<li>等待直到某个操作所有参与者都准备就绪再继续执行。</li>
</ul>
</li>
</ul>
<h3 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 闭锁：CountDownLatch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义等待线程执行的个数</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        MyCountDownLatch myCountDownLatch = <span class="keyword">new</span> MyCountDownLatch(countDownLatch);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 如果少于5个程序会一直不停止，多余5个程序会在5个线程执行完后执行await()后的代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(myCountDownLatch).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"线程执行耗时=====================&gt;"</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCountDownLatch</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCountDownLatch</span><span class="params">(CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    String name = Thread.currentThread().getName();</span><br><span class="line">                    System.out.println(name + <span class="string">"----&gt;"</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 一个线程执行完后将count值减1</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h2><ul>
<li><p>在JDK1.5之后提供的新的创建执行线程的方式。Callable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会<strong>返回结果</strong>，并且无法<strong>抛出经过检查的异常</strong>。</p>
</li>
<li><p>Callable 需要依赖FutureTask ，FutureTask 也可以<strong>用作闭锁</strong>。</p>
</li>
</ul>
<h3 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执行Callable方式，需要FutureTask实现类的支持，用于接收运算结果。FutureTask是Future接口的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">		<span class="comment">//1.执行 Callable 方式，需要 FutureTask实现类的支持，用于接收运算结果。</span></span><br><span class="line">		FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(td);</span><br><span class="line">		<span class="keyword">new</span> Thread(result).start();</span><br><span class="line">		<span class="comment">//2.接收线程运算后的结果</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Integer sum = result.get();  <span class="comment">//FutureTask 可用于 闭锁</span></span><br><span class="line">			System.out.println(sum);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">			sum += i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lock-同步锁"><a href="#Lock-同步锁" class="headerlink" title="Lock 同步锁"></a>Lock 同步锁</h2><ul>
<li>在 Java 5.0 之前，协调共享对象的访问时可以使用的机 制只有 synchronized 和 volatile 。Java 5.0 后增加Lock等一些新的机制，但并不是一种替代内置锁的方法，而是当内置锁不适用时，作为一种可选择的高级功能。</li>
<li>ReentrantLock 实现了 Lock 接口，并提供了与 synchronized 相同的互斥性和内存可见性。但相较于 synchronized 提供了更高的处理锁的灵活性。</li>
<li>Lock底层实现是Volatile与CAS算法。</li>
</ul>
<h3 id="Lock和Synchronized区别"><a href="#Lock和Synchronized区别" class="headerlink" title="Lock和Synchronized区别"></a>Lock和Synchronized区别</h3><ul>
<li><p>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p>
</li>
<li><p>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p>
</li>
<li><p>Lock可以让等待锁的线程响应中断（t.interrupt()），而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p>
</li>
<li><p>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。（boolean t.tryLock()）</p>
</li>
<li><p>Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）</p>
</li>
<li><p>性能上来说，在资源竞争不激烈的情形下，Lock性能稍微比synchronized差点（编译程序通常会尽可能的进行优化synchronized）。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。</p>
<p><a href="https://juejin.im/post/5a43ad786fb9a0450909cb5f" target="_blank" rel="noopener">synchronized和lock比较</a></p>
</li>
</ul>
<h3 id="Java锁类型"><a href="#Java锁类型" class="headerlink" title="Java锁类型"></a>Java锁类型</h3><ul>
<li><p><strong>可重入锁</strong>：锁基于线程分配，而不是基于方法分配。</p>
<ul>
<li>synchronized 为可重入锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在线程进入 f1() 方法时已经获得了对象的锁，因此在 f1() 中调用 f2() 时，不需要重新申请锁</span></span><br><span class="line">  f2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// to do</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ReentrantLock 可重入锁。</li>
</ul>
</li>
<li><p><strong>可中断锁</strong>：</p>
<ul>
<li>synchronized 会导致线程无限等待，不可中断</li>
<li>Lock 可以中断等待，即 <code>t.interrupt()</code>。想要能够响应中断，需使用 <code>lock.lockInterruptibly()</code></li>
</ul>
</li>
<li><p><strong>公平锁</strong>：</p>
<ul>
<li><p>公平锁：加锁前检查是否有排队等待的线程，先来先得 FIFO，即先排队，再尝试获取锁</p>
</li>
<li><p>非公平锁：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待，即先尝试获取锁，再排队</p>
</li>
<li><p>ReentrantLock 默认是非公平锁，可以通过构造方法设置为公平锁 <code>ReentrantLock(boolean fair)</code></p>
</li>
</ul>
</li>
<li><p><strong>读写锁</strong>：</p>
<ul>
<li>若 读锁 被占用，则申请写锁的线程会等待，申请读锁的线程不用等待</li>
<li>若 写锁 被占用，则申请写锁或读锁的线程都会等待</li>
<li>ReadWriteLock 为读写锁的接口，ReentrantReadWriteLock 为一个实现类。</li>
</ul>
</li>
<li><p><strong>自旋锁</strong>：没有获取到锁，线程不会挂起，会自选循环等待一段时间后继续尝试申请锁</p>
<p><a href="https://www.jianshu.com/p/d644207c4fec" target="_blank" rel="noopener">java锁类型</a></p>
</li>
</ul>
<h3 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一、用于解决多线程安全问题的方式：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * synchronized:隐式锁</span></span><br><span class="line"><span class="comment"> * 1. 同步代码块</span></span><br><span class="line"><span class="comment"> * 2. 同步方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * jdk 1.5 后：</span></span><br><span class="line"><span class="comment"> * 3. 同步锁 Lock</span></span><br><span class="line"><span class="comment"> * 注意：是一个显示锁，需要通过 lock() 方法上锁，必须通过 unlock() 方法进行释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">		<span class="keyword">new</span> Thread(ticket, <span class="string">"1号窗口"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(ticket, <span class="string">"2号窗口"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(ticket, <span class="string">"3号窗口"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 显式上锁</span></span><br><span class="line">			lock.lock(); </span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(tick &gt; <span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">200</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">" 完成售票，余票为："</span> + --tick);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="comment">// 释放锁，注意！！！必须在finally里释放锁</span></span><br><span class="line">				lock.unlock(); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Condition-控制线程通信"><a href="#Condition-控制线程通信" class="headerlink" title="Condition 控制线程通信"></a>Condition 控制线程通信</h2><ul>
<li><p>Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用 法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的 功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。</p>
</li>
<li><p>在 Condition 对象中，与 wait、notify 和 notifyAll （Object）方法对应的分别是 await、signal 和 signalAll。</p>
<p><strong>注意</strong>！signal和notify方法一样并不会释放锁，只是通知调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。只有在lock.unlock()方法执行完后，condition.await()方法才会继续执行。</p>
</li>
<li><p>Condition 实例实质上被绑定到一个锁上。要<strong>为特定 Lock 实例获得 Condition 实例</strong>，请使用 newCondition() 方法。</p>
</li>
</ul>
<h3 id="示例代码（Object-控制线程通信）"><a href="#示例代码（Object-控制线程通信）" class="headerlink" title="示例代码（Object 控制线程通信）"></a>示例代码（Object 控制线程通信）</h3><ul>
<li>主类（启动生产者消费者）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProductorAndConsumer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line">        Productor2 productor = <span class="keyword">new</span> Productor2(clerk);</span><br><span class="line">        Consumer2 consumer = <span class="keyword">new</span> Consumer2(clerk);</span><br><span class="line">        <span class="comment">// 为虚假唤醒问题定义多个生产者消费者</span></span><br><span class="line">        <span class="keyword">new</span> Thread(productor,<span class="string">"生产者A1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(productor,<span class="string">"生产者A2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer,<span class="string">"消费者B1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer,<span class="string">"消费者B2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>业务类（操作有状态的成员变量）</p>
<ol>
<li><p>在没加synchronized之前</p>
<p>问题：会出现成员变量同步问题</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生产者A---------&gt;4</span><br><span class="line">消费者B---------&gt;0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>加了synchronized，没wait和notifyAll之前</p>
<p>问题：会出现数据已满的情况下，生产者还在不断生产数据，造成数据丢失。（或则数据为空情况下消费者还在不断尝试消费数据，浪费资源。）</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">生产者A---------&gt;5</span><br><span class="line">满</span><br><span class="line">满</span><br><span class="line">满</span><br><span class="line">消费者B---------&gt;4</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>加了wait和notifyAll，但数据已满（空）的wait()操作，和正常消费（生产）notifyAll()操作，在不同的分支中执行。</p>
<p>问题：当没有生产者生产（produce为1），但还有两个消费者进程消费时，wait操作没有notifyAll通知，线程卡在wait()，等待唤醒。同理，生产者比消费者少时也会出现这个问题！</p>
<p>原因：因为wait保证了逻辑向下执行是有资源可以使用的（资源是满足条件的），所以必须让notifyAll能够执行，唤醒处于wait()的线程。</p>
<p>解决：删掉else，使else里代码和if 在同级，使if里wait()被唤醒后能向下执行notifyAll()</p>
</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> product ;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.product &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"空"</span>);</span><br><span class="line">            <span class="comment">// 可能抛出InterruptedException</span></span><br><span class="line">			<span class="keyword">this</span>.wait();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"---&gt;"</span>+ --product);</span><br><span class="line">			<span class="comment">// 消费了资源，通知其他wait()的线程可以开始执行</span></span><br><span class="line">			<span class="keyword">this</span>.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 产品超过5个就为满了</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.product &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"满"</span>);</span><br><span class="line">			<span class="keyword">this</span>.wait();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"---&gt;"</span>+ ++product);</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>虚假唤醒问题</p>
<p>问题：数据不满足的线程会被唤醒，执行业务（生产者A1生产1份数据，消费者B1，B2都在消费数据了）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">生产者A1---------&gt;1</span><br><span class="line">消费者B2---------&gt;0</span><br><span class="line">消费者B1---------&gt;-1</span><br></pre></td></tr></table></figure>

<p>原因：在对wait外面的条件是if，只判断一次。如果有多个生产者或者消费者，当一个生产者（消费者）notifyAll唤醒了其他的进程。wait方法后的代码不管条件是否还满足都继续执行，出现虚假唤醒问题。</p>
<p>解决：if 修改为while</p>
</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> product ;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.product &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"空"</span>);</span><br><span class="line">            <span class="comment">// 可能抛出InterruptedException</span></span><br><span class="line">			<span class="keyword">this</span>.wait();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">"---&gt;"</span>+ --product);</span><br><span class="line">		<span class="comment">// 消费了资源，通知其他wait()的线程可以开始执行</span></span><br><span class="line">		<span class="keyword">this</span>.notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 产品超过5个就为满了</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.product &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"满"</span>);</span><br><span class="line">			<span class="keyword">this</span>.wait();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">"---&gt;"</span>+ ++product);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<ul>
<li>生产者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clerk.add();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消费者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clerk.dec();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例代码（Condition-控制线程通信）"><a href="#示例代码（Condition-控制线程通信）" class="headerlink" title="示例代码（Condition 控制线程通信）"></a>示例代码（Condition 控制线程通信）</h3><ul>
<li>主类（启动生产者消费者）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProductorAndConsumerForLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Clerk2 clerk = <span class="keyword">new</span> Clerk2();</span><br><span class="line">		Productor pro = <span class="keyword">new</span> Productor(clerk);</span><br><span class="line">		Consumer con = <span class="keyword">new</span> Consumer(clerk);</span><br><span class="line">		<span class="keyword">new</span> Thread(pro, <span class="string">"生产者 A"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(con, <span class="string">"消费者 B"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>业务类（操作有状态的成员变量）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> product = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 进货</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 为了避免虚假唤醒，应该总是使用在循环中。</span></span><br><span class="line">			<span class="keyword">while</span> (product &gt;= <span class="number">1</span>) &#123; </span><br><span class="line">				System.out.println(<span class="string">"产品已满！"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					condition.await();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + ++product);</span><br><span class="line">            <span class="comment">// 并不会释放锁，只是通知调用过wait方法的线程可以去参与获得锁的竞争</span></span><br><span class="line">			condition.signalAll();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// unlock()必须要放在finally里</span></span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 卖货</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (product &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">"缺货！"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					condition.await();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + --product);</span><br><span class="line">			condition.signalAll();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生产者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Clerk2 clerk;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(Clerk2 clerk)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			clerk.get();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消费者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Clerk2 clerk;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Clerk2 clerk)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			clerk.sale();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程按序交替（打印ABC）"><a href="#线程按序交替（打印ABC）" class="headerlink" title="线程按序交替（打印ABC）"></a>线程按序交替（打印ABC）</h2><ul>
<li>题目：编写一个程序，开启 3 个线程，这三个线程的 ID 分别为 A、B、C，每个线程将自己的 ID 在屏幕上打印10遍，要求输出的结果必须按顺序显示。如：ABCABCABC…… 依次递归</li>
</ul>
<h3 id="示例代码-6"><a href="#示例代码-6" class="headerlink" title="示例代码"></a>示例代码</h3><ul>
<li>输出结果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A	1</span><br><span class="line">B	1</span><br><span class="line">C	1</span><br><span class="line">-----------------------------------</span><br><span class="line">A	2</span><br><span class="line">B	2</span><br><span class="line">C	2</span><br><span class="line">-----------------------------------</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>创建线程，调用打印方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestABCAlternate</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AlternateDemo ad = <span class="keyword">new</span> AlternateDemo();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">					ad.loopA(i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">"A"</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">					ad.loopB(i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">"B"</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">					ad.loopC(i);</span><br><span class="line">					System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">"C"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程间通信类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlternateDemo</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当前正在执行线程的标记。只有线程标记符合才能继续执行，否则才线程等待且释放锁(lock.await())。</span></span><br><span class="line">    <span class="comment">// 如果没有这个标记，可能会A线程在B.signal()时，B还没有进入B.await()状态。</span></span><br><span class="line">    <span class="comment">// B.signal()执行完后B.await()再执行会造成B线程一直处于等待状态，不能够被唤醒。</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">	<span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">	<span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> totalLoop : 循环第几轮</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopA</span><span class="params">(<span class="keyword">int</span> totalLoop)</span></span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//1. 判断</span></span><br><span class="line">			<span class="keyword">if</span>(number != <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 等同与this.wait()。wait，notify，notifyAll都是Object方法;</span></span><br><span class="line">				condition1.await();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//2. 打印</span></span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + totalLoop);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//3. 唤醒  </span></span><br><span class="line">			number = <span class="number">2</span>;</span><br><span class="line">			condition2.signal();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopB</span><span class="params">(<span class="keyword">int</span> totalLoop)</span></span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//1. 判断</span></span><br><span class="line">			<span class="keyword">if</span>(number != <span class="number">2</span>)&#123;</span><br><span class="line">				condition2.await();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//2. 打印</span></span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + totalLoop);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//3. 唤醒</span></span><br><span class="line">			number = <span class="number">3</span>;</span><br><span class="line">			condition3.signal();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopC</span><span class="params">(<span class="keyword">int</span> totalLoop)</span></span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//1. 判断</span></span><br><span class="line">			<span class="keyword">if</span>(number != <span class="number">3</span>)&#123;</span><br><span class="line">				condition3.await();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//2. 打印</span></span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + totalLoop);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//3. 唤醒</span></span><br><span class="line">			number = <span class="number">1</span>;</span><br><span class="line">			condition1.signal();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h2><ul>
<li>ReadWriteLock 维护了一对相关的锁，一个用于只读操作， 另一个用于写入操作。只要没有 writer，读取锁可以由 多个 reader 线程同时保持。写入锁是独占的。</li>
<li>ReadWriteLock 读取操作通常不会改变共享资源，但执行写入操作时，必须独占方式来获取锁。对于读取操作占多数的数据结构。 ReadWriteLock 能提供比独占锁更高的并发性。而对于只读的数据结构，其中包含的不变性可以完全不需要考虑加锁操作。</li>
</ul>
<h3 id="示例代码-7"><a href="#示例代码-7" class="headerlink" title="示例代码"></a>示例代码</h3><ul>
<li>创建线程，调用读写方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 写写/读写 需要“互斥”; 读读 不需要互斥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReadWriteLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ReadWriteLockDemo rw = <span class="keyword">new</span> ReadWriteLockDemo();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 1个写线程</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            </span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				rw.set((<span class="keyword">int</span>)(Math.random() * <span class="number">101</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">"Write:"</span>).start();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 多个读线程</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                </span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					rw.get();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, <span class="string">"Read:"</span>).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读写锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//读</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">		lock.readLock().lock(); <span class="comment">//上读锁</span></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + number);</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			lock.readLock().unlock(); <span class="comment">//释放读锁</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//写</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">		lock.writeLock().lock(); <span class="comment">//上写锁</span></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">			<span class="keyword">this</span>.number = number;</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			lock.writeLock().unlock(); <span class="comment">//释放写锁</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h2><ul>
<li>一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用 其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法。</li>
<li>非静态同步方法锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的 synchronized方法。</li>
<li>不共用锁情况：<ul>
<li>普通方法和同步方法；</li>
<li>两个对象调用非静态同步方法；</li>
<li>静态同步方法和非静态同步方法</li>
</ul>
</li>
<li>所有的非静态同步方法用的都是同一把锁——实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非 静态同步方法释放锁就可以获取他们自己的锁。</li>
<li>所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</li>
</ul>
<h3 id="题目：判断打印的-“one”-or-“two”"><a href="#题目：判断打印的-“one”-or-“two”" class="headerlink" title="题目：判断打印的 “one” or “two”"></a>题目：判断打印的 “one” or “two”</h3><ol>
<li><p>两个普通同步方法，两个线程，标准打印， 打印?         // one  two或 （较小概率two  one ）</p>
<p>分析：因为调用start()方法线程只是进入<strong>就绪状态</strong>，等CPU等分配资源后才进入执行状态，先进入就绪状态的不一定先执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread8Monitor</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Number number = <span class="keyword">new</span> Number();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                number.getOne();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                number.getTwo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"one"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"two"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>新增 Thread.sleep(100) 给 getOne() ，打印?        // one  two或（较小概率two  one ）</p>
<p>分析：Thread.sleep() 方法并不会释放锁，在同一个Number对象，getTwo()方法获取不到锁。</p>
</li>
</ol>
<ol start="3">
<li><p>新增普通方法 getThree() , 打印?        // three  one  two 或（较小概率two  three one 和 three  two  one）</p>
<p>   分析：普通方法和同步锁方法执行无关。</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread8Monitor</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Number number = <span class="keyword">new</span> Number();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                number.getOne();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                number.getTwo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number.getThree();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"one"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"two"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"three"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>两个普通同步方法，两个 Number 对象，打印?        //  two  one </p>
<p>   分析：非静态同步方法不同对象不共用锁</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread8Monitor</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Number number = <span class="keyword">new</span> Number();</span><br><span class="line">        Number number2 = <span class="keyword">new</span> Number();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                number.getOne();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                number2.getTwo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"one"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"two"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>修改 getOne() 为静态同步方法，打印?        // two  one</p>
<p>   分析：对象锁和类锁不共用锁，不存在竞争关系</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread8Monitor</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Number number = <span class="keyword">new</span> Number();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                number.getOne();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                number.getTwo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getOne</span><span class="params">()</span> </span>&#123; <span class="comment">//Number.class</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"one"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getTwo</span><span class="params">()</span></span>&#123; <span class="comment">//this</span></span><br><span class="line">		System.out.println(<span class="string">"two"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="6">
<li><p>修改两个方法均为静态同步方法，一个 Number 对象?        // one  two</p>
<p>   分析：静态同步方法之间存在对类锁的竞争</p>
</li>
</ol>
<ol start="7">
<li><p>一个静态同步方法，一个非静态同步方法，两个 Number 对象?        //  two  one  two </p>
<p>   分析：不同对象，且不同锁类型，没关系</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread8Monitor</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Number number = <span class="keyword">new</span> Number();</span><br><span class="line">        Number number2 = <span class="keyword">new</span> Number();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                number.getOne();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                number2.getTwo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getOne</span><span class="params">()</span> </span>&#123; <span class="comment">//Number.class</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"one"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getTwo</span><span class="params">()</span></span>&#123; <span class="comment">//this</span></span><br><span class="line">		System.out.println(<span class="string">"two"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="8">
<li><p>两个静态同步方法，两个 Number 对象?        // one  two或则 two  one </p>
<p>   分析：静态同步方法，一个类下的所有对象都竞争同一个类锁</p>
</li>
</ol>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li>线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。</li>
<li><strong>第四种</strong>获取线程的方法：线程池，一个 ExecutorService，它使用可能的几个池线程之 一执行每个提交的任务，通常使用 Executors 工厂方法配置。</li>
<li>线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。<h3 id="线程池的体系结构"><a href="#线程池的体系结构" class="headerlink" title="线程池的体系结构"></a>线程池的体系结构</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.Executor : 根接口（负责线程的使用与调度）</span><br><span class="line">	|--**ExecutorService 子接口（线程池的主要接口）</span><br><span class="line">		|--AbstractExecutorService 抽象类</span><br><span class="line">			|--ThreadPoolExecutor 线程池的实现类</span><br><span class="line">		|--ScheduledExecutorService 子接口（负责线程的调度）</span><br><span class="line">				|--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor，实现 ScheduledExecutorService</span><br></pre></td></tr></table></figure>

<h3 id="线程池方法"><a href="#线程池方法" class="headerlink" title="线程池方法"></a>线程池方法</h3><ul>
<li>为了便于跨大量上下文使用，此类（ThreadPoolExecutor）提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 ：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量，可以进行自动线程回收）</span></span><br><span class="line">Executors.newCachedThreadPool()</span><br><span class="line"><span class="comment">//（固定大小线程池）</span></span><br><span class="line">Executors.newFixedThreadPool(<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//（单个后台线程）</span></span><br><span class="line">Executors.newSingleThreadExecutor()</span><br><span class="line"><span class="comment">// ====ThreadPoolExecutor====它们均为大多数使用场景预定义了设置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（创建固定大小的线程，可以延迟或定时的执行任务)</span></span><br><span class="line">ScheduledExecutorService.newScheduledThreadPool()</span><br></pre></td></tr></table></figure>

<h3 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h3><ul>
<li>ThreadPoolExecutor 的构造函数：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory, <span class="comment">/* 可选 */</span></span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler <span class="comment">/* 可选 */</span>)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>ThreadPoolExecutor构造函数参数：</p>
<ul>
<li><strong>corePoolSize</strong>：the number of threads to keep in the pool, even if they are idle, unless {@code allowCoreThreadTimeOut} is set</li>
<li><strong>maximumPoolSize</strong>：the maximum number of threads to allow in the pool</li>
<li><strong>keepAliveTime</strong>：when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating</li>
<li>unit：the time unit for the {@code keepAliveTime} argument</li>
<li><strong>workQueue</strong>：the queue to use for holding tasks before they are executed.  This queue will hold only the {@code Runnable} tasks submitted by the {@code execute} method.</li>
<li>threadFactory：the factory to use when the executor creates a new thread</li>
<li>handler：the handler to use when execution is blocked because the thread bounds and queue capacities are reached</li>
</ul>
</li>
<li><p>其他线程池参数：</p>
<ul>
<li><p>allowCoreThreadTimeout：If false (default), core threads stay alive even when idle. If true, core threads use keepAliveTime to time out waiting for work.</p>
<p>设置方法：threadPoolExecutor.allowCoreThreadTimeout(boolean value)</p>
</li>
<li><p><strong>queueCapacity</strong>：BlockingQueue<runnable> workQueue存放任务的队列（存放需要被线程池执行的线程队列）。queueCapacity就是任务队列的长度，队列长度设置过大，会导致任务响应时间过长。</runnable></p>
</li>
</ul>
</li>
<li><p>线程池按以下行为执行任务</p>
<ol>
<li>当线程数小于核心线程数时，创建线程。</li>
<li>当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。</li>
<li>当线程数大于等于核心线程数，且任务队列已满<ol>
<li>若线程数小于最大线程数，创建线程</li>
<li>若线程数等于最大线程数，抛出异常，拒绝任务</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="示例代码-8"><a href="#示例代码-8" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//1. 创建线程池</span></span><br><span class="line">		ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">		List&lt;Future&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 2. 为线程池中的线程分配任务</span></span><br><span class="line">			Future&lt;Integer&gt; future = pool.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;()&#123;</span><br><span class="line">                </span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">					<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">						sum += i;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> sum;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			list.add(future);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//3. 关闭线程池（等待线程池中所有的线程任务完成后才会关闭，不会接受新的线程任务）</span></span><br><span class="line">		pool.shutdown();</span><br><span class="line">		<span class="comment">// 线程执行完返回结果都保存在 Future&lt;Integer&gt; future中</span></span><br><span class="line">		<span class="keyword">for</span> (Future&lt;Integer&gt; future : list) &#123;</span><br><span class="line">			System.out.println(future.get());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程调度（ScheduledExecutorService）"><a href="#线程调度（ScheduledExecutorService）" class="headerlink" title="线程调度（ScheduledExecutorService）"></a>线程调度（ScheduledExecutorService）</h2><ul>
<li>ScheduledExecutorService，可安排在给定的延迟后运行或定期执行的命令</li>
</ul>
<h3 id="示例代码-9"><a href="#示例代码-9" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestScheduledThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// ScheduledThreadPoolExecutor实现类接口为ScheduledExecutorService</span></span><br><span class="line">		ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			Future&lt;Integer&gt; result = pool.schedule(<span class="keyword">new</span> Callable&lt;Integer&gt;()&#123;</span><br><span class="line"></span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">					<span class="keyword">int</span> num = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);<span class="comment">//生成随机数</span></span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + num);</span><br><span class="line">					<span class="keyword">return</span> num;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, <span class="number">1</span>, TimeUnit.SECONDS); <span class="comment">// 每隔1秒开始执行这个线程任务</span></span><br><span class="line">			System.out.println(result.get());</span><br><span class="line">		&#125;</span><br><span class="line">		pool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ForkJoinPool分支-合并框架-工作窃取"><a href="#ForkJoinPool分支-合并框架-工作窃取" class="headerlink" title="ForkJoinPool分支/合并框架 工作窃取"></a>ForkJoinPool分支/合并框架 工作窃取</h2><h3 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork/Join 框架"></a>Fork/Join 框架</h3><p>Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成 若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总</p>
<p><img src="//yoursite.com/2019/07/30/JAVA并发编程学习总结/fork-join%E6%A1%86%E6%9E%B6.jpg" alt="fork-join框架"></p>
<img src="/2019/07/30/JAVA并发编程学习总结/fork-join框架.jpg">

<h3 id="Fork-Join-框架与线程池的区别"><a href="#Fork-Join-框架与线程池的区别" class="headerlink" title="Fork/Join 框架与线程池的区别"></a>Fork/Join 框架与线程池的区别</h3><ul>
<li>采用 “工作窃取”模式（work-stealing）：<br>当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</li>
<li>相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务 的处理方式上.在一般的线程池中，如果一个线程正在执行的任务由于某些 原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中， 如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间，提高了性能。</li>
</ul>
<h3 id="示例代码-10"><a href="#示例代码-10" class="headerlink" title="示例代码"></a>示例代码</h3><ul>
<li>调用ForkJoin实现类方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForkJoinPool</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Instant start = Instant.now(); <span class="comment">//开始时间</span></span><br><span class="line">		ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool(); <span class="comment">//创建ForkJoin线程池</span></span><br><span class="line">		ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinSumCalculate(<span class="number">0L</span>, <span class="number">50000000000L</span>);</span><br><span class="line">		Long sum = pool.invoke(task); <span class="comment">//执行ForkJoin实现类方法</span></span><br><span class="line">		System.out.println(sum);</span><br><span class="line">		Instant end = Instant.now(); <span class="comment">//结束时间</span></span><br><span class="line">		System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ForkJoin实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * jdk1.7推出的RecursiveTask 继承了 ForkJoinTask ；</span></span><br><span class="line"><span class="comment"> * ForkJoinTask 实现了 Future ，Serializable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSumCalculate</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">259195479995561737L</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THURSHOLD = <span class="number">10000L</span>;  <span class="comment">//临界值</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculate</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.start = start;</span><br><span class="line">		<span class="keyword">this</span>.end = end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> length = end - start;</span><br><span class="line">		<span class="keyword">if</span>(length &lt;= THURSHOLD)&#123;</span><br><span class="line">			<span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">				sum += i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> sum;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">long</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">			ForkJoinSumCalculate left = <span class="keyword">new</span> ForkJoinSumCalculate(start, middle); </span><br><span class="line">			left.fork(); <span class="comment">//进行拆分，同时压入线程队列</span></span><br><span class="line">			ForkJoinSumCalculate right = <span class="keyword">new</span> ForkJoinSumCalculate(middle+<span class="number">1</span>, end);</span><br><span class="line">			right.fork(); <span class="comment">//进行拆分，同时压入线程队列</span></span><br><span class="line">			<span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>jdk1.8 新特性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Long sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">50000000000L</span>)</span><br><span class="line">    .parallel()</span><br><span class="line">    .reduce(<span class="number">0L</span>, Long::sum);</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/24/sparkStreaming笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cilibili">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/sparkStreaming笔记/" itemprop="url">SparkStreaming学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-24T15:15:49+08:00">
                2019-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spark/" itemprop="url" rel="index">
                    <span itemprop="name">spark</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SparkStreaming"><a href="#SparkStreaming" class="headerlink" title="SparkStreaming"></a>SparkStreaming</h1><h2 id="SparkStreaming-1"><a href="#SparkStreaming-1" class="headerlink" title="SparkStreaming"></a>SparkStreaming</h2><p>导入spark-streaming依赖</p>
<h3 id="整合Kafka"><a href="#整合Kafka" class="headerlink" title="整合Kafka"></a>整合Kafka</h3><p>导入spark-streaming-kafka-0-8_2.11依赖（0-8kafka版本，2.11scala版本，0.8和0.10两个版本）</p>
<p><strong>注意</strong> ：version可能是要求和spark-core版本一致，详见<a href="sparkStreaming学习总结/错误日志.xml">错误日志</a></p>
<h4 id="无状态WordCount"><a href="#无状态WordCount" class="headerlink" title="无状态WordCount"></a>无状态WordCount</h4><ol>
<li>创建StreamingContxt（用sparkConf）</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"KafkaWordCount"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>)) <span class="comment">//内部创建sparkContext(conf)</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Kafka参数配置</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> zkQuorum = <span class="string">"node-1:2181,node-2:2181,node-3:2181"</span></span><br><span class="line"><span class="keyword">val</span> groupId = <span class="string">"g1"</span></span><br><span class="line"><span class="keyword">val</span> topic = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>](<span class="string">"xiaoniuabc"</span> -&gt; <span class="number">1</span>) <span class="comment">//1是topic对应的线程数</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>AWL方式创建DStream（write ahead logs ）</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kafak的ReceiverInputDStream[(String, String)]里面装的是一个元组（key，value是实际内容）</span></span><br><span class="line"><span class="keyword">val</span> data: <span class="type">ReceiverInputDStream</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="type">KafkaUtils</span>.createStream(ssc, zkQuorum, groupId, topic)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>对DStream进行操作</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出value里写的实际内容</span></span><br><span class="line"><span class="keyword">val</span> lines: <span class="type">DStream</span>[<span class="type">String</span>] = data.map(_._2)</span><br><span class="line"><span class="comment">//对DSteam进行操作，你操作这个抽象（代理，描述），就像操作一个本地的集合一样</span></span><br><span class="line"><span class="keyword">val</span> words: <span class="type">DStream</span>[<span class="type">String</span>] = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"><span class="keyword">val</span> wordAndOne: <span class="type">DStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = words.map((_, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">val</span> reduced: <span class="type">DStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordAndOne.reduceByKey(_+_)</span><br><span class="line">reduced.print()</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>SparkStreaming程序启动和退出</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动sparksteaming程序</span></span><br><span class="line">ssc.start()</span><br><span class="line"><span class="comment">//等待优雅的退出</span></span><br><span class="line">ssc.awaitTermination()</span><br></pre></td></tr></table></figure>

<h4 id="有状态WordCount"><a href="#有状态WordCount" class="headerlink" title="有状态WordCount"></a>有状态WordCount</h4><ol start="0">
<li>可以在main方法外面定义updateStateByKey的函数参数</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 第一个参数：聚合的key，就是单词</span></span><br><span class="line"><span class="comment">  * 第二个参数：当前批次产生批次该单词在每一个分区出现的次数</span></span><br><span class="line"><span class="comment">  * 第三个参数：初始值或累加的中间结果</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">val</span> updateFunc = (iter: <span class="type">Iterator</span>[(<span class="type">String</span>, <span class="type">Seq</span>[<span class="type">Int</span>], <span class="type">Option</span>[<span class="type">Int</span>])]) =&gt; &#123;</span><br><span class="line">  iter.map(t =&gt; (t._1, t._2.sum + t._3.getOrElse(<span class="number">0</span>)))    <span class="comment">// -----&gt;方式一</span></span><br><span class="line">  <span class="comment">//iter.map&#123; case(x, y, z) =&gt; (x, y.sum + z.getOrElse(0))&#125; -----&gt;方式二（模式匹配）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建StreamingContxt（用sparkConf）</p>
</li>
<li><p><strong>设置checkpoint</strong></p>
</li>
</ol>
<p>​    <strong>注意</strong> ：设置了checkpoint过后，对DStream的操作中间结果都涉及到写入写出，<u>所以对象可能会存在序列化问题</u> （比如DStream的foreachRDD方法里面代码在Driver端执行，但用到外部对象也会出现序列化问题）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果要使用课更新历史数据（累加），那么就要把终结结果保存起来</span></span><br><span class="line">ssc.checkpoint(<span class="string">"./ck"</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Kafka参数配置</li>
<li>AWL方式创建DStream（write ahead logs ）</li>
<li>对DStream进行操作</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单词和一组合在一起</span></span><br><span class="line"><span class="keyword">val</span> wordAndOne: <span class="type">DStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = words.map((_, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//聚合所有批次数据（但是只记录程序开始执行之后的数据，程序停止则丢失数据）</span></span><br><span class="line"><span class="comment">//ssc.sparkContext.defaultParallelism表示分区器使用默认的分区数量</span></span><br><span class="line"><span class="keyword">val</span> reduced: <span class="type">DStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordAndOne.updateStateByKey(updateFunc, <span class="keyword">new</span> <span class="type">HashPartitioner</span>(ssc.sparkContext.defaultParallelism), <span class="literal">true</span>) </span><br><span class="line"><span class="comment">//打印结果(Action)</span></span><br><span class="line">reduced.print()</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>SparkStreaming程序启动和退出</li>
</ol>
<h3 id="直连方式-SparkStreaming-kafka-0-8"><a href="#直连方式-SparkStreaming-kafka-0-8" class="headerlink" title="直连方式-SparkStreaming-kafka-0.8"></a>直连方式-SparkStreaming-kafka-0.8</h3><h4 id="1-创建StreamingContxt（用sparkConf）"><a href="#1-创建StreamingContxt（用sparkConf）" class="headerlink" title="1. 创建StreamingContxt（用sparkConf）"></a>1. 创建StreamingContxt（用sparkConf）</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建SparkConf</span></span><br><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"OrderCount"</span>).setMaster(<span class="string">"local[4]"</span>)</span><br><span class="line"><span class="comment">//创建SparkStreaming，并设置间隔时间</span></span><br><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Duration</span>(<span class="number">5000</span>))</span><br></pre></td></tr></table></figure>

<h4 id="2-Kafka参数配置"><a href="#2-Kafka参数配置" class="headerlink" title="2. Kafka参数配置"></a>2. Kafka参数配置</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定组名</span></span><br><span class="line"><span class="keyword">val</span> group = <span class="string">"g001"</span></span><br><span class="line"><span class="comment">//指定消费的 topic 名字</span></span><br><span class="line"><span class="keyword">val</span> topic = <span class="string">"wordcount"</span></span><br><span class="line"><span class="comment">//指定kafka的broker地址(sparkStream的Task直连到kafka的分区上，用更加底层的API消费，效率更高)</span></span><br><span class="line"><span class="keyword">val</span> brokerList = <span class="string">"node-4:9092,node-5:9092,node-6:9092"</span></span><br><span class="line"><span class="comment">//指定zk的地址，后期更新消费的偏移量时使用(以后可以使用Redis、MySQL来记录偏移量)</span></span><br><span class="line"><span class="keyword">val</span> zkQuorum = <span class="string">"node-1:2181,node-2:2181,node-3:2181"</span></span><br><span class="line"><span class="comment">//创建 stream 时使用的 topic 名字集合，SparkStreaming可同时消费多个topic</span></span><br><span class="line"><span class="keyword">val</span> topics: <span class="type">Set</span>[<span class="type">String</span>] = <span class="type">Set</span>(topic)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备kafka的参数</span></span><br><span class="line"><span class="keyword">val</span> kafkaParams = <span class="type">Map</span>(</span><br><span class="line">    <span class="comment">//"key.deserializer" -&gt; classOf[StringDeserializer],</span></span><br><span class="line">    <span class="comment">//"value.deserializer" -&gt; classOf[StringDeserializer],</span></span><br><span class="line">    <span class="comment">//"deserializer.encoding" -&gt; "GB2312", //配置读取Kafka中数据的编码</span></span><br><span class="line">    <span class="string">"metadata.broker.list"</span> -&gt; brokerList,</span><br><span class="line">    <span class="string">"group.id"</span> -&gt; group,</span><br><span class="line">    <span class="comment">//从头（上次偏移量）开始读取数据，LargestTimeString:启动后开始读数据</span></span><br><span class="line">    <span class="string">"auto.offset.reset"</span> -&gt; kafka.api.<span class="type">OffsetRequest</span>.<span class="type">SmallestTimeString</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="3-创建zookeeper偏移量保存路径"><a href="#3-创建zookeeper偏移量保存路径" class="headerlink" title="3. 创建zookeeper偏移量保存路径"></a>3. 创建zookeeper偏移量保存路径</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个 ZKGroupTopicDirs 对象,其实是指定往zk中写入数据的目录，用于保存偏移量</span></span><br><span class="line"><span class="keyword">val</span> topicDirs = <span class="keyword">new</span> <span class="type">ZKGroupTopicDirs</span>(group, topic)</span><br><span class="line"><span class="comment">//获取 zookeeper 中的路径 "/g001/offsets/wordcount/"</span></span><br><span class="line"><span class="keyword">val</span> zkTopicPath = <span class="string">s"<span class="subst">$&#123;topicDirs.consumerOffsetDir&#125;</span>"</span></span><br></pre></td></tr></table></figure>

<h4 id="4-创建zookeeper客户端"><a href="#4-创建zookeeper客户端" class="headerlink" title="4. 创建zookeeper客户端"></a>4. 创建zookeeper客户端</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zookeeper 的host 和 ip，创建一个 client,用于跟新偏移量量的</span></span><br><span class="line"><span class="comment">//是zookeeper的客户端，可以从zk中读取偏移量数据，并更新偏移量</span></span><br><span class="line"><span class="keyword">val</span> zkClient = <span class="keyword">new</span> <span class="type">ZkClient</span>(zkQuorum)</span><br></pre></td></tr></table></figure>

<h4 id="5-定义保存kafkaSteam和偏移量的变量"><a href="#5-定义保存kafkaSteam和偏移量的变量" class="headerlink" title="5. 定义保存kafkaSteam和偏移量的变量"></a>5. 定义保存<strong>kafkaSteam</strong>和<strong>偏移量</strong>的变量</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kafkaStream的值根据是否记录过便宜量分两种方法读取</span></span><br><span class="line"><span class="keyword">var</span> kafkaStream: <span class="type">InputDStream</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="literal">null</span></span><br><span class="line"><span class="comment">//如果 zookeeper 中有保存 offset，我们会利用这个 offset 作为 kafkaStream 的起始位置</span></span><br><span class="line"><span class="keyword">var</span> fromOffsets: <span class="type">Map</span>[<span class="type">TopicAndPartition</span>, <span class="type">Long</span>] = <span class="type">Map</span>()</span><br></pre></td></tr></table></figure>

<h4 id="6-查询同个group-amp-topic下分区数量，分是否保存过offset分别处理"><a href="#6-查询同个group-amp-topic下分区数量，分是否保存过offset分别处理" class="headerlink" title="6. 查询同个group&amp;topic下分区数量，分是否保存过offset分别处理"></a>6. 查询同个group&amp;topic下分区数量，分是否保存过offset分别处理</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询该路径下是否子节点（默认有字节点为我们自己保存不同 partition 时生成的）</span></span><br><span class="line"><span class="comment">// /g001/offsets/wordcount/0/10001"  --&gt; 0号分区/偏移量10001</span></span><br><span class="line"><span class="comment">// /g001/offsets/wordcount/1/30001"  ...</span></span><br><span class="line"><span class="comment">// /g001/offsets/wordcount/2/10001"  ...</span></span><br><span class="line"><span class="comment">//zkTopicPath  -&gt; /g001/offsets/wordcount/</span></span><br><span class="line"><span class="keyword">val</span> children = zkClient.countChildren(zkTopicPath)<span class="comment">//返回分区数量</span></span><br></pre></td></tr></table></figure>

<h4 id="7-调用KafkaUtils-createDirectStream创建kafkaStream"><a href="#7-调用KafkaUtils-createDirectStream创建kafkaStream" class="headerlink" title="7. 调用KafkaUtils.createDirectStream创建kafkaStream"></a>7. 调用KafkaUtils.createDirectStream创建kafkaStream</h4><ul>
<li><p>如存在偏移量</p>
<ol>
<li>取出偏移量存入之前创建的保存偏移量的参数(fromOffsets)中</li>
<li>创建函数将MessageAndMetadata[String, String]取出message转成tupple类型</li>
<li>调用createDirectStream，传入ssc、kafka参数、fromOffsets、和MessageAndMetadata函数</li>
</ol>
</li>
<li><p>未存在偏移量</p>
<ol>
<li><p>直接调用createDirectStream，传入ssc、kafka参数、和topics  (Set[String]类型) </p>
<p>注：可能因为fromOffsets: Map[TopicAndPartition, Long]存在topic信息所以不用传topics了</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果保存过 offset</span></span><br><span class="line"><span class="keyword">if</span> (children &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until children) &#123;</span><br><span class="line">    <span class="comment">// 假如存在偏移量保存路径：/g001/offsets/wordcount/0/10001</span></span><br><span class="line">    <span class="comment">// $zkTopicPath/$&#123;i&#125;:g001/offsets/wordcount/0</span></span><br><span class="line">	<span class="comment">// partitionOffset:10001</span></span><br><span class="line">    <span class="keyword">val</span> partitionOffset = zkClient.readData[<span class="type">String</span>](<span class="string">s"<span class="subst">$zkTopicPath</span>/<span class="subst">$&#123;i&#125;</span>"</span>)</span><br><span class="line">    <span class="comment">// wordcount/0</span></span><br><span class="line">    <span class="keyword">val</span> tp = <span class="type">TopicAndPartition</span>(topic, i)</span><br><span class="line">    <span class="comment">//将不同 partition 对应的 offset 增加到 fromOffsets 中</span></span><br><span class="line">    <span class="comment">// wordcount/0 -&gt; 10001</span></span><br><span class="line">    fromOffsets += (tp -&gt; partitionOffset.toLong)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Key: kafka的key   values: "hello tom hello jerry"</span></span><br><span class="line">  <span class="comment">//这个会将 kafka 的消息进行 transform，最终 kafak 的数据都会变成 (kafka的key, message) 这样的 tuple，也可以用（mmd.topic(), mmd.message()）获得topic,value这样的数据</span></span><br><span class="line">  <span class="keyword">val</span> messageHandler = (mmd: <span class="type">MessageAndMetadata</span>[<span class="type">String</span>, <span class="type">String</span>]) =&gt; (mmd.key(), mmd.message())																</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//通过KafkaUtils创建直连的DStream（fromOffsets参数的作用是:按照前面计算好了的偏移量继续消费数据）</span></span><br><span class="line">  <span class="comment">//[String, String, StringDecoder, StringDecoder,     (String, String)]</span></span><br><span class="line">  <span class="comment">//  key    value    key的解码方式   value的解码方式 </span></span><br><span class="line">  kafkaStream = <span class="type">KafkaUtils</span>.createDirectStream[<span class="type">String</span>, <span class="type">String</span>, <span class="type">StringDecoder</span>, <span class="type">StringDecoder</span>, (<span class="type">String</span>, <span class="type">String</span>)](ssc, kafkaParams, fromOffsets, messageHandler)</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//如果未保存，根据 kafkaParam 的配置使用最新(largest)或者最旧的（smallest） offset</span></span><br><span class="line">  kafkaStream = <span class="type">KafkaUtils</span>.createDirectStream[<span class="type">String</span>, <span class="type">String</span>, <span class="type">StringDecoder</span>, <span class="type">StringDecoder</span>](ssc, kafkaParams, topics)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-定义保存偏移量范围的变量"><a href="#8-定义保存偏移量范围的变量" class="headerlink" title="8. 定义保存偏移量范围的变量"></a>8. 定义保存<strong>偏移量范围</strong>的变量</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//偏移量的范围</span></span><br><span class="line"><span class="keyword">var</span> offsetRanges = <span class="type">Array</span>[<span class="type">OffsetRange</span>]()</span><br></pre></td></tr></table></figure>

<h4 id="9-调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存"><a href="#9-调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存" class="headerlink" title="9. 调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存"></a>9. 调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从kafka读取的消息，DStream的Transform方法可以将当前批次的RDD获取出来</span></span><br><span class="line"><span class="comment">//该transform方法计算获取到当前批次RDD,然后将RDD的偏移量取出来，然后在将RDD返回到DStream</span></span><br><span class="line"><span class="keyword">val</span> transform: <span class="type">DStream</span>[(<span class="type">String</span>, <span class="type">String</span>)] = kafkaStream.transform &#123; rdd =&gt;</span><br><span class="line">  <span class="comment">//得到该 rdd 对应 kafka 的消息的 offset</span></span><br><span class="line">  <span class="comment">//该RDD是一个KafkaRDD，可以获得偏移量的范围</span></span><br><span class="line">  offsetRanges = rdd.asInstanceOf[<span class="type">HasOffsetRanges</span>].offsetRanges</span><br><span class="line">  rdd<span class="comment">//将原kafkaStream原封返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-只获取kafkaStream中的message"><a href="#10-只获取kafkaStream中的message" class="headerlink" title="10. 只获取kafkaStream中的message"></a>10. 只获取kafkaStream中的message</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> messages: <span class="type">DStream</span>[<span class="type">String</span>] = transform.map(_._2)</span><br></pre></td></tr></table></figure>

<h4 id="11-对DStream调用foreachRDD进行操作每个RDD流"><a href="#11-对DStream调用foreachRDD进行操作每个RDD流" class="headerlink" title="11. 对DStream调用foreachRDD进行操作每个RDD流"></a>11. 对DStream调用foreachRDD进行操作每个RDD流</h4><ul>
<li><h4 id="将偏移量保存到zookeeper的gropu-offset-topic-partition路径下"><a href="#将偏移量保存到zookeeper的gropu-offset-topic-partition路径下" class="headerlink" title="将偏移量保存到zookeeper的gropu/offset/topic/partition路径下"></a>将偏移量保存到zookeeper的gropu/offset/topic/partition路径下</h4></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依次迭代DStream中的RDD</span></span><br><span class="line"><span class="comment">//注意!：kafkaStream.foreachRDD里面的业务逻辑是在Driver端执行、kafkaRDD.maps里定义的方法才是在Excutor里执行，maps方法是在Driver端执行</span></span><br><span class="line"><span class="comment">//foreachRDD只是把每个RDD拿出来，没有触发Action</span></span><br><span class="line">messages.foreachRDD &#123; rdd =&gt;</span><br><span class="line">  <span class="comment">//对RDD进行操作，触发Action</span></span><br><span class="line">  rdd.foreachPartition(partition =&gt;</span><br><span class="line">    partition.foreach(x =&gt; &#123;</span><br><span class="line">      println(x)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (o &lt;- offsetRanges) &#123;</span><br><span class="line">    <span class="comment">//  /g001/offsets/wordcount/0</span></span><br><span class="line">    <span class="keyword">val</span> zkPath = <span class="string">s"<span class="subst">$&#123;topicDirs.consumerOffsetDir&#125;</span>/<span class="subst">$&#123;o.partition&#125;</span>"</span></span><br><span class="line">    <span class="comment">//将该 partition 的 offset 保存到 zookeeper</span></span><br><span class="line">    <span class="comment">//  /g001/offsets/wordcount/0/20000（untilOffset是截至的偏移量）</span></span><br><span class="line">    <span class="type">ZkUtils</span>.updatePersistentPath(zkClient, zkPath, o.untilOffset.toString)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-SparkStreaming程序启动和退出"><a href="#12-SparkStreaming程序启动和退出" class="headerlink" title="12. SparkStreaming程序启动和退出"></a>12. SparkStreaming程序启动和退出</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssc.start()</span><br><span class="line">ssc.awaitTermination()</span><br></pre></td></tr></table></figure>

<p><strong>备注</strong>：也可以在kafkaStream.foreachRDD中对kafkaRDD强转获取到偏移量（只能对kafkaRDD进行强转）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直连方式只有在KafkaDStream的RDD中才能获取偏移量，那么就不能再调用DStream的Transformation</span></span><br><span class="line"><span class="comment">//所以只能在kafkaStream调用foreachRDD，获取RDD的偏移量，然后就是对RDD进行操作了</span></span><br><span class="line"><span class="comment">//依次迭代KafkaDStream中的KafkaRDD</span></span><br><span class="line">kafkaStream.foreachRDD &#123; kafkaRDD =&gt;</span><br><span class="line">  <span class="comment">//只有KafkaRDD可以强转成HasOffsetRanges，并获取到偏移量</span></span><br><span class="line">  offsetRanges = kafkaRDD.asInstanceOf[<span class="type">HasOffsetRanges</span>].offsetRanges</span><br><span class="line">  <span class="keyword">val</span> lines: <span class="type">RDD</span>[<span class="type">String</span>] = kafkaRDD.map(_._2)</span><br></pre></td></tr></table></figure>

<h4 id="13-补充：kafka直连方式消费多个topic"><a href="#13-补充：kafka直连方式消费多个topic" class="headerlink" title="13. 补充：kafka直连方式消费多个topic"></a>13. 补充：<a href="https://blog.csdn.net/Lu_Xiao_Yue/article/details/84075565" target="_blank" rel="noopener">kafka直连方式消费多个topic</a></h4><h4 id="Kafka知识补充"><a href="#Kafka知识补充" class="headerlink" title="Kafka知识补充"></a>Kafka知识补充</h4><h5 id="1-Kafka分区"><a href="#1-Kafka分区" class="headerlink" title="1. Kafka分区"></a>1. Kafka分区</h5><ul>
<li>0、1、2代表数据的不同分区</li>
<li>0`、1`、2`代表不同的副本</li>
<li>生产者向一个leader分区发送数据，消费者也向leader分区消费数据（可以配置消费者向非leader分区消费）</li>
<li>数据的分区数量可以任意，副本数量不大于启动kafka机器的数量<br><img src="//yoursite.com/2019/07/24/sparkStreaming笔记/sparkStreaming%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%5Ckafka%E5%88%86%E5%8C%BA%E5%8E%9F%E7%90%86.png" alt="Kafka分区原理"></li>
</ul>


<h5 id="2-kafka直连"><a href="#2-kafka直连" class="headerlink" title="2. kafka直连"></a>2. kafka直连</h5><p>Direct方式采用Kafka简单的consumer api方式来读取数据，无需经由ZooKeeper，此种方式不再需要专门Receiver来持续不断读取数据。当batch任务触发时，由Executor读取数据，并参与到其他Executor的数据计算过程中去。driver来决定读取多少offsets，并将offsets交由checkpoints来维护。将触发下次batch任务，再由Executor读取Kafka数据并计算。从此过程我们可以发现Direct方式无需Receiver读取数据，而是需要计算时再读取数据，所以Direct方式的数据消费对内存的要求不高，只需要考虑批量计算所需要的内存即可；另外batch任务堆积时，也不会影响数据堆积。其具体读取方式如下图：</p>
<p>Receiver方式：<img src="//yoursite.com/2019/07/24/sparkStreaming笔记/sparkStreaming%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%5CReceiver%E6%96%B9%E5%BC%8F.png" alt="Receiver方式"></p>






<p>直连方式：<img src="//yoursite.com/2019/07/24/sparkStreaming笔记/sparkStreaming%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%5C%E7%9B%B4%E8%BF%9E%E6%96%B9%E5%BC%8F.png" alt="直连方式"></p>




<h3 id="直连方式-SparkStreaming-kafka-0-10"><a href="#直连方式-SparkStreaming-kafka-0-10" class="headerlink" title="直连方式-SparkStreaming-kafka-0.10"></a>直连方式-SparkStreaming-kafka-0.10</h3><h4 id="1-创建StreamingContxt（用sparkConf）-1"><a href="#1-创建StreamingContxt（用sparkConf）-1" class="headerlink" title="1. 创建StreamingContxt（用sparkConf）"></a>1. 创建StreamingContxt（用sparkConf）</h4><h4 id="2-Kafka参数配置-1"><a href="#2-Kafka参数配置-1" class="headerlink" title="2. Kafka参数配置"></a>2. Kafka参数配置</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> topics = <span class="type">Array</span>(topic)	<span class="comment">//数组方式保存topics</span></span><br><span class="line"><span class="keyword">val</span> kafkaParams = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Object</span>](</span><br><span class="line">    <span class="comment">//即0.8版的broker-list</span></span><br><span class="line">   <span class="string">"bootstrap.servers"</span> -&gt; <span class="string">"node-1:9092,node-2:9092,node-3:9092"</span>,</span><br><span class="line">   <span class="string">"key.deserializer"</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">   <span class="string">"value.deserializer"</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">   <span class="string">"group.id"</span> -&gt; group,</span><br><span class="line">   <span class="string">"auto.offset.reset"</span> -&gt; <span class="string">"earliest"</span>, <span class="comment">// lastest</span></span><br><span class="line">   <span class="string">"enable.auto.commit"</span> -&gt; (<span class="literal">false</span>: java.lang.<span class="type">Boolean</span>) <span class="comment">// false代表自己写程序提交偏移量 </span></span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<h4 id="3-创建SparkDStream-一个API"><a href="#3-创建SparkDStream-一个API" class="headerlink" title="3. 创建SparkDStream(一个API)"></a>3. 创建SparkDStream(一个API)</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用直连方式读取kafka中的数据，在Kafka中记录读取偏移量</span></span><br><span class="line"><span class="comment">//spark-kafka-0.8把偏移量保存在zookeeper里，也可存在redis等里</span></span><br><span class="line"><span class="keyword">val</span> stream = <span class="type">KafkaUtils</span>.createDirectStream[<span class="type">String</span>, <span class="type">String</span>](</span><br><span class="line">  streamingContext,</span><br><span class="line">  <span class="comment">//位置策略（如果kafka和spark程序部署在一起，会有最优位置）</span></span><br><span class="line">  <span class="type">PreferConsistent</span>,</span><br><span class="line">  <span class="comment">//订阅的策略（可以指定用正则的方式读取topic，比如my-ordsers-.*）</span></span><br><span class="line">  <span class="type">Subscribe</span>[<span class="type">String</span>, <span class="type">String</span>](topics, kafkaParams)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="4-获取跟新偏移量，操作DStream"><a href="#4-获取跟新偏移量，操作DStream" class="headerlink" title="4. 获取跟新偏移量，操作DStream"></a>4. 获取跟新偏移量，操作DStream</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代DStream中的RDD，将每一个时间点对于的RDD拿出来</span></span><br><span class="line">stream.foreachRDD &#123; rdd =&gt;</span><br><span class="line">  <span class="keyword">if</span>(!rdd.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">//获取该RDD对于的偏移量</span></span><br><span class="line">    <span class="keyword">val</span> offsetRanges = rdd.asInstanceOf[<span class="type">HasOffsetRanges</span>].offsetRanges</span><br><span class="line">	<span class="comment">//拿出对于的数据，foreach是一个aciton</span></span><br><span class="line">    rdd.foreach&#123; line =&gt;</span><br><span class="line">		<span class="comment">//Kafka在消费偏移量之后的数据不一定按顺序进行消费（因为有多个Consumer同时进行消费）</span></span><br><span class="line">		println(line.key() + <span class="string">" "</span> + line.value())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新偏移量</span></span><br><span class="line">    <span class="comment">// some time later, after outputs have completed</span></span><br><span class="line">    stream.asInstanceOf[<span class="type">CanCommitOffsets</span>].commitAsync(offsetRanges)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-SparkStreaming程序启动和退出"><a href="#5-SparkStreaming程序启动和退出" class="headerlink" title="5. SparkStreaming程序启动和退出"></a>5. SparkStreaming程序启动和退出</h4><h3 id="订单项目示例（离线和实时）-非常重要"><a href="#订单项目示例（离线和实时）-非常重要" class="headerlink" title="订单项目示例（离线和实时）*非常重要*"></a>订单项目示例（离线和实时）*非常重要*</h3><p>数据：A 202.106.196.115 手机 iPhone8 8000</p>
<h4 id="0-用到的工具类（Object）："><a href="#0-用到的工具类（Object）：" class="headerlink" title="0. 用到的工具类（Object）："></a>0. 用到的工具类（Object）：</h4><ul>
<li>离线计算 IP-地址 规则</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">broadcastIpRules</span></span>(ssc: <span class="type">StreamingContext</span>, ipRulesPath: <span class="type">String</span>): <span class="type">Broadcast</span>[<span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)]] = &#123;</span><br><span class="line">  <span class="comment">//现获取sparkContext</span></span><br><span class="line">  <span class="keyword">val</span> sc = ssc.sparkContext</span><br><span class="line">  <span class="keyword">val</span> rulesLines:<span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(ipRulesPath)</span><br><span class="line">  <span class="comment">//整理ip规则数据</span></span><br><span class="line">  <span class="keyword">val</span> ipRulesRDD: <span class="type">RDD</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)] = rulesLines.map(line =&gt; &#123;</span><br><span class="line"> 	...</span><br><span class="line">    (startNum, endNum, province)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//将分散在多个Executor中的部分IP规则收集到Driver端</span></span><br><span class="line">  <span class="keyword">val</span> rulesInDriver: <span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)] = ipRulesRDD.collect()</span><br><span class="line">  <span class="comment">//将Driver端的数据广播到Executor</span></span><br><span class="line">  <span class="comment">//广播变量的引用（还在Driver端）</span></span><br><span class="line">  sc.broadcast(rulesInDriver)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>计算成交总金额（一个批次收入存入Redis，流数据不断累加）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateIncome</span></span>(fields: <span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">String</span>]]) = &#123;</span><br><span class="line">  <span class="comment">//将数据计算后写入到Reids</span></span><br><span class="line">  <span class="keyword">val</span> priceRDD: <span class="type">RDD</span>[<span class="type">Double</span>] = fields.map(arr =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> price = arr(<span class="number">4</span>).toDouble</span><br><span class="line">    price</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//reduce是一个Action，会把结果返回到Driver端</span></span><br><span class="line">  <span class="comment">//将当前批次的总金额返回了</span></span><br><span class="line">  <span class="keyword">val</span> sum: <span class="type">Double</span> = priceRDD.reduce(_+_)</span><br><span class="line">  <span class="comment">//获取一个jedis连接（在Driver端创建）</span></span><br><span class="line">  <span class="keyword">val</span> conn = <span class="type">JedisConnectionPool</span>.getConnection()</span><br><span class="line">  <span class="comment">//将历史值和当前的值进行累加</span></span><br><span class="line">  <span class="comment">//conn.set(Constant.TOTAL_INCOME, sum.toString)</span></span><br><span class="line">  conn.incrByFloat(<span class="type">Constant</span>.<span class="type">TOTAL_INCOME</span>, sum)</span><br><span class="line">  <span class="comment">//释放连接</span></span><br><span class="line">  conn.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>计算商品分类成交总金额（一个批次收入存入Redis，流数据不断累加）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateItem</span></span>(fields: <span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">String</span>]]) = &#123;</span><br><span class="line">  <span class="comment">//备注：对field的map方法是在哪一端调用的呢？Driver，只是map里面的方法还没执行</span></span><br><span class="line">  <span class="keyword">val</span> itemAndPrice: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = fields.map(arr =&gt; &#123;</span><br><span class="line">    <span class="comment">//分类</span></span><br><span class="line">    <span class="keyword">val</span> item = arr(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">//金额</span></span><br><span class="line">    <span class="keyword">val</span> parice = arr(<span class="number">4</span>).toDouble</span><br><span class="line">    (item, parice)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//按照商品分类进行聚合</span></span><br><span class="line">  <span class="keyword">val</span> reduced: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = itemAndPrice.reduceByKey(_+_)</span><br><span class="line">  <span class="comment">//将当前批次的数据累加到Redis中</span></span><br><span class="line">  <span class="comment">//foreachPartition是一个Action</span></span><br><span class="line">  <span class="comment">//现在这种方式，jeids的连接是在哪一端创建的（Driver）</span></span><br><span class="line">  <span class="comment">//在Driver端拿Jedis连接不好(要序列化)</span></span><br><span class="line">  <span class="comment">//val conn = JedisConnectionPool.getConnection()</span></span><br><span class="line">  reduced.foreachPartition(part =&gt; &#123;</span><br><span class="line">    <span class="comment">//获取一个Jedis连接</span></span><br><span class="line">    <span class="comment">//这个连接其实是在Executor中的获取的</span></span><br><span class="line">    <span class="comment">//JedisConnectionPool在一个Executor进程中只有1个实例（单例）</span></span><br><span class="line">    <span class="keyword">val</span> conn = <span class="type">JedisConnectionPool</span>.getConnection()</span><br><span class="line">    part.foreach(t =&gt; &#123;</span><br><span class="line">      <span class="comment">//一个连接更新多条数据</span></span><br><span class="line">      conn.incrByFloat(t._1, t._2)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//将当前分区中的数据跟新完在关闭连接</span></span><br><span class="line">    conn.close()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>计算省份成交总金额（一个批次收入存入Redis，流数据不断累加）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateZone</span></span>(fields: <span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">String</span>]], broadcastRef: <span class="type">Broadcast</span>[<span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)]]) = &#123;</span><br><span class="line">  <span class="keyword">val</span> provinceAndPrice: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = fields.map(arr =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> ip = arr(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> price = arr(<span class="number">4</span>).toDouble</span><br><span class="line">    <span class="keyword">val</span> ipNum = <span class="type">MyUtils</span>.ip2Long(ip)</span><br><span class="line">    <span class="comment">//在Executor中获取到广播的全部规则</span></span><br><span class="line">    <span class="keyword">val</span> allRules: <span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)] = broadcastRef.value</span><br><span class="line">    <span class="comment">//二分法查找,根据Ip计算归属地</span></span><br><span class="line">    <span class="keyword">val</span> index = <span class="type">MyUtils</span>.binarySearch(allRules, ipNum)</span><br><span class="line">    <span class="keyword">var</span> province = <span class="string">"未知"</span></span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">      province = allRules(index)._3</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省份，订单金额</span></span><br><span class="line">    (province, price)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//按省份进行聚合</span></span><br><span class="line">  <span class="keyword">val</span> reduced: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = provinceAndPrice.reduceByKey(_+_)</span><br><span class="line">  <span class="comment">//将数据跟新到Redis</span></span><br><span class="line"><span class="comment">//key不多的话可以用.foreach</span></span><br><span class="line">  reduced.foreachPartition(part =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> conn = <span class="type">JedisConnectionPool</span>.getConnection()</span><br><span class="line">    part.foreach(t =&gt; &#123;</span><br><span class="line">      conn.incrByFloat(t._1, t._2)</span><br><span class="line">    &#125;)</span><br><span class="line">    conn.close()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-创建StreamingContxt（用sparkConf）-2"><a href="#1-创建StreamingContxt（用sparkConf）-2" class="headerlink" title="1. 创建StreamingContxt（用sparkConf）"></a>1. 创建StreamingContxt（用sparkConf）</h4><h4 id="2-广播离线计算的-IP-地址-规则"><a href="#2-广播离线计算的-IP-地址-规则" class="headerlink" title="*2. *广播离线计算的 IP-地址 规则**"></a>*<em>2. *</em>广播离线计算的 IP-地址 规则**</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> broadcastRef: <span class="type">Broadcast</span>[<span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)]] = <span class="type">IPUtils</span>.broadcastIpRules(ssc, <span class="string">"/Users/zx/Desktop/temp/spark-24/spark-4/ip/ip.txt"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-Kafka参数配置"><a href="#3-Kafka参数配置" class="headerlink" title="3. Kafka参数配置"></a>3. Kafka参数配置</h4><h4 id="4-创建zookeeper偏移量保存路径"><a href="#4-创建zookeeper偏移量保存路径" class="headerlink" title="4. 创建zookeeper偏移量保存路径"></a>4. 创建zookeeper偏移量保存路径</h4><h4 id="5-创建zookeeper客户端"><a href="#5-创建zookeeper客户端" class="headerlink" title="5. 创建zookeeper客户端"></a>5. 创建zookeeper客户端</h4><h4 id="6-定义保存kafkaSteam和偏移量的变量"><a href="#6-定义保存kafkaSteam和偏移量的变量" class="headerlink" title="6. 定义保存kafkaSteam和偏移量的变量"></a>6. 定义保存<strong>kafkaSteam</strong>和<strong>偏移量</strong>的变量</h4><h4 id="7-查询同个group-amp-topic下分区数量，分是否保存过offset分别处理"><a href="#7-查询同个group-amp-topic下分区数量，分是否保存过offset分别处理" class="headerlink" title="7. 查询同个group&amp;topic下分区数量，分是否保存过offset分别处理"></a>7. 查询同个group&amp;topic下分区数量，分是否保存过offset分别处理</h4><h4 id="8-调用KafkaUtils-createDirectStream创建kafkaStream"><a href="#8-调用KafkaUtils-createDirectStream创建kafkaStream" class="headerlink" title="8. 调用KafkaUtils.createDirectStream创建kafkaStream"></a>8. 调用KafkaUtils.createDirectStream创建kafkaStream</h4><h4 id="9-定义保存偏移量范围的变量"><a href="#9-定义保存偏移量范围的变量" class="headerlink" title="9. 定义保存偏移量范围的变量"></a>9. 定义保存<strong>偏移量范围</strong>的变量</h4><h4 id="10-调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存"><a href="#10-调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存" class="headerlink" title="10. 调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存"></a>10. 调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存</h4><h4 id="11-只获取kafkaStream中的message"><a href="#11-只获取kafkaStream中的message" class="headerlink" title="11. 只获取kafkaStream中的message"></a>11. 只获取kafkaStream中的message</h4><h4 id="12-对DStream调用foreachRDD进行操作每个RDD流"><a href="#12-对DStream调用foreachRDD进行操作每个RDD流" class="headerlink" title="***12. 对DStream调用foreachRDD进行操作每个RDD流"></a>***12. 对DStream调用foreachRDD进行操作每个RDD流</h4><ul>
<li><h4 id="将偏移量保存到zookeeper的gropu-offset-topic-partition路径下-1"><a href="#将偏移量保存到zookeeper的gropu-offset-topic-partition路径下-1" class="headerlink" title="将偏移量保存到zookeeper的gropu/offset/topic/partition路径下"></a>将偏移量保存到zookeeper的gropu/offset/topic/partition路径下</h4></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意!：kafkaStream.foreachRDD里面的业务逻辑是在Driver端执行、kafkaRDD.maps是在Excutor里执行</span></span><br><span class="line">kafkaStream.foreachRDD &#123; kafkaRDD =&gt;</span><br><span class="line">  <span class="comment">//判断当前的kafkaStream中的RDD是否有数据</span></span><br><span class="line">  <span class="comment">//注意！！！！！kafkaRDD为空下面的map方法就不能执行（容易踩坑点）</span></span><br><span class="line">  <span class="keyword">if</span>(!kafkaRDD.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">//只有KafkaRDD可以强转成HasOffsetRanges，并获取到偏移量</span></span><br><span class="line">    <span class="comment">//offsetRanges = kafkaRDD.asInstanceOf[HasOffsetRanges].offsetRanges</span></span><br><span class="line">    <span class="comment">//				备注：=============================&gt;在这里获取偏移量范围取代第10步操作</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//val lines: RDD[String] = kafkaRDD.map(_._2)</span></span><br><span class="line">	<span class="comment">//				备注：================&gt;在这里获取kafkaStream中的message取代第11步操作</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//整理数据</span></span><br><span class="line">	<span class="comment">//备注：RDD在Driver端生成,但里面函数没执行，可以把RDD引用传递给方法</span></span><br><span class="line">    <span class="keyword">val</span> fields: <span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">String</span>]] = lines.map(_.split(<span class="string">" "</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//流式数据在这些定义的方法里不断经过处理，计算结果保存到Redis中</span></span><br><span class="line">    <span class="comment">//计算成交总金额</span></span><br><span class="line">    <span class="type">CalculateUtil</span>.calculateIncome(fields)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算商品分类金额</span></span><br><span class="line">    <span class="type">CalculateUtil</span>.calculateItem(fields)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算区域成交金额</span></span><br><span class="line">    <span class="type">CalculateUtil</span>.calculateZone(fields, broadcastRef)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//偏移量更新在哪一端（Driver）</span></span><br><span class="line">    <span class="keyword">for</span> (o &lt;- offsetRanges) &#123;</span><br><span class="line">      <span class="comment">//  /g001/offsets/wordcount/0</span></span><br><span class="line">      <span class="keyword">val</span> zkPath = <span class="string">s"<span class="subst">$&#123;topicDirs.consumerOffsetDir&#125;</span>/<span class="subst">$&#123;o.partition&#125;</span>"</span></span><br><span class="line">      <span class="comment">//将该 partition 的 offset 保存到 zookeeper</span></span><br><span class="line">      <span class="comment">//  /g001/offsets/wordcount/0/20000</span></span><br><span class="line">      <span class="type">ZkUtils</span>.updatePersistentPath(zkClient, zkPath, o.untilOffset.toString)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-SparkStreaming程序启动和退出"><a href="#13-SparkStreaming程序启动和退出" class="headerlink" title="13. SparkStreaming程序启动和退出"></a>13. SparkStreaming程序启动和退出</h4><h3 id="直接监听Socket"><a href="#直接监听Socket" class="headerlink" title="直接监听Socket"></a>直接监听Socket</h3><p>在Linux上用yum安装nc    yum install -y nc</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程数量必须要两个以上</span></span><br><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"SteamingWordCount"</span>).setMaster(<span class="string">"local[2]"</span>) </span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"><span class="comment">//StreamingContext是对SparkContext的包装，包了一层就增加了实时的功能</span></span><br><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sc, <span class="type">Milliseconds</span>(<span class="number">5000</span>))</span><br><span class="line"><span class="comment">//有了StreamingContext，就可以创建SparkStreaming的抽象了DSteam</span></span><br><span class="line"><span class="comment">//从一个socket端口中读取数据</span></span><br><span class="line"><span class="keyword">val</span> lines: <span class="type">ReceiverInputDStream</span>[<span class="type">String</span>] = ssc.socketTextStream(<span class="string">"192.168.1.207"</span>, <span class="number">8888</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Spark-On-Yarn"><a href="#Spark-On-Yarn" class="headerlink" title="Spark On Yarn"></a>Spark On Yarn</h2><p><a href="sparkStreaming学习总结/spark-on-yarn.docx">详见文档</a></p>
<ol>
<li><p>环境</p>
<ul>
<li><p>安装hadoop：需要安装HDFS模块和YARN模块，HDFS必须安装，spark运行时要把jar包存放到HDFS上。</p>
</li>
<li><p>安装Spark：解压Spark安装程序到一台服务器上，修改spark-env.sh配置文件，spark程序将作为YARN的客户端用于提交任务</p>
<p>Tips：或者把HADOOP_CONF_DIR在/etc/profile里配置</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.8.0_131</span><br><span class="line">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/Hadoop</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>提交任务</p>
<ul>
<li><strong>cluster模式</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit --class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master yarn \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--driver-memory 1g \</span><br><span class="line">--executor-memory 1g \</span><br><span class="line">--executor-cores 2 \</span><br><span class="line">--queue default \  			#默认资源调度器</span><br><span class="line">lib/spark-examples*.jar \</span><br><span class="line">10						#参数</span><br></pre></td></tr></table></figure>

<ul>
<li><p>client模式</p>
<p>修改$HADOOP_HOME /etc/hadoop所有yarn节点的yarn-site.xml，在该文件中添加如下配置</p>
<p>修改内存检测机制</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.pmem-check-enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.vmem-check-enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--deploy-mode client \ #其余不变</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>两种模式的区别</p>
<ul>
<li><p>cluster模式：Driver程序在YARN中运行，应用的运行结果不能在客户端显示，所以最好运行那些将结果最终保存在外部存储介质（如HDFS、Redis、Mysql）而非stdout输出的应用程序，客户端的终端显示的仅是作为YARN的job的简单运行状况。</p>
</li>
<li><p>client模式：Driver运行在Client上，应用程序运行结果会在客户端显示，所有适合运行结果有输出的应用程序（如spark-shell）</p>
</li>
</ul>
</li>
</ol>
<h2 id="DStream知识补充"><a href="#DStream知识补充" class="headerlink" title="DStream知识补充"></a>DStream知识补充</h2><p>Spark Streaming是一个基于Spark Core之上的实时计算框架，可以从很多数据源消费数据并对数据进行处理，在Spark Streaing中有一个最基本的抽象叫DStream（代理），本质上就是一系列连续的RDD，DStream其实就是对RDD的封装。DStream可以任务是一个RDD的工厂，该DStream里面生产都是相同业务逻辑的RDD，只不过是RDD里面要读取数据的不相同</p>
<p>深入理解DStream：他是sparkStreaming中的一个最基本的抽象，代表了一下列连续的数据流，本质上是一系列连续的RDD，你对DStream进行操作，就是对RDD进行操作。DStream每隔一段时间生成一个RDD，你对DStream进行操作，本质上是对里面的对应时间的RDD进行操作。</p>
<p>DSteam和DStream之间存在依赖关系，在一个固定的时间点，对个存在依赖关系的DSrteam对应的RDD也存在依赖关系，每个一个固定的时间，其实生产了一个小的DAG，周期性的将生成的小DAG提交到集群中运行。</p>
<p><img src="//yoursite.com/2019/07/24/sparkStreaming笔记/DStream%E8%AF%B4%E6%98%8E.png" alt="DStream抽象表示图"></p>



          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/24/sparkStreaming学习总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cilibili">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/sparkStreaming学习总结/" itemprop="url">SparkStreaming学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-24T15:15:49+08:00">
                2019-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spark/" itemprop="url" rel="index">
                    <span itemprop="name">spark</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SparkStreaming"><a href="#SparkStreaming" class="headerlink" title="SparkStreaming"></a>SparkStreaming</h1><h2 id="SparkStreaming-1"><a href="#SparkStreaming-1" class="headerlink" title="SparkStreaming"></a>SparkStreaming</h2><p>导入spark-streaming依赖</p>
<h3 id="整合Kafka"><a href="#整合Kafka" class="headerlink" title="整合Kafka"></a>整合Kafka</h3><p>导入spark-streaming-kafka-0-8_2.11依赖（0-8kafka版本，2.11scala版本，0.8和0.10两个版本）</p>
<p><strong>注意</strong> ：version可能是要求和spark-core版本一致，详见<a href="sparkStreaming学习总结/错误日志.xml">错误日志</a></p>
<h4 id="无状态WordCount"><a href="#无状态WordCount" class="headerlink" title="无状态WordCount"></a>无状态WordCount</h4><ol>
<li>创建StreamingContxt（用sparkConf）</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"KafkaWordCount"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>)) <span class="comment">//内部创建sparkContext(conf)</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Kafka参数配置</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> zkQuorum = <span class="string">"node-1:2181,node-2:2181,node-3:2181"</span></span><br><span class="line"><span class="keyword">val</span> groupId = <span class="string">"g1"</span></span><br><span class="line"><span class="keyword">val</span> topic = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>](<span class="string">"xiaoniuabc"</span> -&gt; <span class="number">1</span>) <span class="comment">//1是topic对应的线程数</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>AWL方式创建DStream（write ahead logs ）</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kafak的ReceiverInputDStream[(String, String)]里面装的是一个元组（key，value是实际内容）</span></span><br><span class="line"><span class="keyword">val</span> data: <span class="type">ReceiverInputDStream</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="type">KafkaUtils</span>.createStream(ssc, zkQuorum, groupId, topic)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>对DStream进行操作</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出value里写的实际内容</span></span><br><span class="line"><span class="keyword">val</span> lines: <span class="type">DStream</span>[<span class="type">String</span>] = data.map(_._2)</span><br><span class="line"><span class="comment">//对DSteam进行操作，你操作这个抽象（代理，描述），就像操作一个本地的集合一样</span></span><br><span class="line"><span class="keyword">val</span> words: <span class="type">DStream</span>[<span class="type">String</span>] = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"><span class="keyword">val</span> wordAndOne: <span class="type">DStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = words.map((_, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">val</span> reduced: <span class="type">DStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordAndOne.reduceByKey(_+_)</span><br><span class="line">reduced.print()</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>SparkStreaming程序启动和退出</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动sparksteaming程序</span></span><br><span class="line">ssc.start()</span><br><span class="line"><span class="comment">//等待优雅的退出</span></span><br><span class="line">ssc.awaitTermination()</span><br></pre></td></tr></table></figure>

<h4 id="有状态WordCount"><a href="#有状态WordCount" class="headerlink" title="有状态WordCount"></a>有状态WordCount</h4><ol start="0">
<li>可以在main方法外面定义updateStateByKey的函数参数</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 第一个参数：聚合的key，就是单词</span></span><br><span class="line"><span class="comment">  * 第二个参数：当前批次产生批次该单词在每一个分区出现的次数</span></span><br><span class="line"><span class="comment">  * 第三个参数：初始值或累加的中间结果</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">val</span> updateFunc = (iter: <span class="type">Iterator</span>[(<span class="type">String</span>, <span class="type">Seq</span>[<span class="type">Int</span>], <span class="type">Option</span>[<span class="type">Int</span>])]) =&gt; &#123;</span><br><span class="line">  iter.map(t =&gt; (t._1, t._2.sum + t._3.getOrElse(<span class="number">0</span>)))    <span class="comment">// -----&gt;方式一</span></span><br><span class="line">  <span class="comment">//iter.map&#123; case(x, y, z) =&gt; (x, y.sum + z.getOrElse(0))&#125; -----&gt;方式二（模式匹配）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建StreamingContxt（用sparkConf）</p>
</li>
<li><p><strong>设置checkpoint</strong></p>
</li>
</ol>
<p>​    <strong>注意</strong> ：设置了checkpoint过后，对DStream的操作中间结果都涉及到写入写出，<u>所以对象可能会存在序列化问题</u> （比如DStream的foreachRDD方法里面代码在Driver端执行，但用到外部对象也会出现序列化问题）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果要使用课更新历史数据（累加），那么就要把终结结果保存起来</span></span><br><span class="line">ssc.checkpoint(<span class="string">"./ck"</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Kafka参数配置</li>
<li>AWL方式创建DStream（write ahead logs ）</li>
<li>对DStream进行操作</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单词和一组合在一起</span></span><br><span class="line"><span class="keyword">val</span> wordAndOne: <span class="type">DStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = words.map((_, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//聚合所有批次数据（但是只记录程序开始执行之后的数据，程序停止则丢失数据）</span></span><br><span class="line"><span class="comment">//ssc.sparkContext.defaultParallelism表示分区器使用默认的分区数量</span></span><br><span class="line"><span class="keyword">val</span> reduced: <span class="type">DStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordAndOne.updateStateByKey(updateFunc, <span class="keyword">new</span> <span class="type">HashPartitioner</span>(ssc.sparkContext.defaultParallelism), <span class="literal">true</span>) </span><br><span class="line"><span class="comment">//打印结果(Action)</span></span><br><span class="line">reduced.print()</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>SparkStreaming程序启动和退出</li>
</ol>
<h3 id="直连方式-SparkStreaming-kafka-0-8"><a href="#直连方式-SparkStreaming-kafka-0-8" class="headerlink" title="直连方式-SparkStreaming-kafka-0.8"></a>直连方式-SparkStreaming-kafka-0.8</h3><h4 id="1-创建StreamingContxt（用sparkConf）"><a href="#1-创建StreamingContxt（用sparkConf）" class="headerlink" title="1. 创建StreamingContxt（用sparkConf）"></a>1. 创建StreamingContxt（用sparkConf）</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建SparkConf</span></span><br><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"OrderCount"</span>).setMaster(<span class="string">"local[4]"</span>)</span><br><span class="line"><span class="comment">//创建SparkStreaming，并设置间隔时间</span></span><br><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Duration</span>(<span class="number">5000</span>))</span><br></pre></td></tr></table></figure>

<h4 id="2-Kafka参数配置"><a href="#2-Kafka参数配置" class="headerlink" title="2. Kafka参数配置"></a>2. Kafka参数配置</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定组名</span></span><br><span class="line"><span class="keyword">val</span> group = <span class="string">"g001"</span></span><br><span class="line"><span class="comment">//指定消费的 topic 名字</span></span><br><span class="line"><span class="keyword">val</span> topic = <span class="string">"wordcount"</span></span><br><span class="line"><span class="comment">//指定kafka的broker地址(sparkStream的Task直连到kafka的分区上，用更加底层的API消费，效率更高)</span></span><br><span class="line"><span class="keyword">val</span> brokerList = <span class="string">"node-4:9092,node-5:9092,node-6:9092"</span></span><br><span class="line"><span class="comment">//指定zk的地址，后期更新消费的偏移量时使用(以后可以使用Redis、MySQL来记录偏移量)</span></span><br><span class="line"><span class="keyword">val</span> zkQuorum = <span class="string">"node-1:2181,node-2:2181,node-3:2181"</span></span><br><span class="line"><span class="comment">//创建 stream 时使用的 topic 名字集合，SparkStreaming可同时消费多个topic</span></span><br><span class="line"><span class="keyword">val</span> topics: <span class="type">Set</span>[<span class="type">String</span>] = <span class="type">Set</span>(topic)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备kafka的参数</span></span><br><span class="line"><span class="keyword">val</span> kafkaParams = <span class="type">Map</span>(</span><br><span class="line">    <span class="comment">//"key.deserializer" -&gt; classOf[StringDeserializer],</span></span><br><span class="line">    <span class="comment">//"value.deserializer" -&gt; classOf[StringDeserializer],</span></span><br><span class="line">    <span class="comment">//"deserializer.encoding" -&gt; "GB2312", //配置读取Kafka中数据的编码</span></span><br><span class="line">    <span class="string">"metadata.broker.list"</span> -&gt; brokerList,</span><br><span class="line">    <span class="string">"group.id"</span> -&gt; group,</span><br><span class="line">    <span class="comment">//从头（上次偏移量）开始读取数据，LargestTimeString:启动后开始读数据</span></span><br><span class="line">    <span class="string">"auto.offset.reset"</span> -&gt; kafka.api.<span class="type">OffsetRequest</span>.<span class="type">SmallestTimeString</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="3-创建zookeeper偏移量保存路径"><a href="#3-创建zookeeper偏移量保存路径" class="headerlink" title="3. 创建zookeeper偏移量保存路径"></a>3. 创建zookeeper偏移量保存路径</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个 ZKGroupTopicDirs 对象,其实是指定往zk中写入数据的目录，用于保存偏移量</span></span><br><span class="line"><span class="keyword">val</span> topicDirs = <span class="keyword">new</span> <span class="type">ZKGroupTopicDirs</span>(group, topic)</span><br><span class="line"><span class="comment">//获取 zookeeper 中的路径 "/g001/offsets/wordcount/"</span></span><br><span class="line"><span class="keyword">val</span> zkTopicPath = <span class="string">s"<span class="subst">$&#123;topicDirs.consumerOffsetDir&#125;</span>"</span></span><br></pre></td></tr></table></figure>

<h4 id="4-创建zookeeper客户端"><a href="#4-创建zookeeper客户端" class="headerlink" title="4. 创建zookeeper客户端"></a>4. 创建zookeeper客户端</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zookeeper 的host 和 ip，创建一个 client,用于跟新偏移量量的</span></span><br><span class="line"><span class="comment">//是zookeeper的客户端，可以从zk中读取偏移量数据，并更新偏移量</span></span><br><span class="line"><span class="keyword">val</span> zkClient = <span class="keyword">new</span> <span class="type">ZkClient</span>(zkQuorum)</span><br></pre></td></tr></table></figure>

<h4 id="5-定义保存kafkaSteam和偏移量的变量"><a href="#5-定义保存kafkaSteam和偏移量的变量" class="headerlink" title="5. 定义保存kafkaSteam和偏移量的变量"></a>5. 定义保存<strong>kafkaSteam</strong>和<strong>偏移量</strong>的变量</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kafkaStream的值根据是否记录过便宜量分两种方法读取</span></span><br><span class="line"><span class="keyword">var</span> kafkaStream: <span class="type">InputDStream</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="literal">null</span></span><br><span class="line"><span class="comment">//如果 zookeeper 中有保存 offset，我们会利用这个 offset 作为 kafkaStream 的起始位置</span></span><br><span class="line"><span class="keyword">var</span> fromOffsets: <span class="type">Map</span>[<span class="type">TopicAndPartition</span>, <span class="type">Long</span>] = <span class="type">Map</span>()</span><br></pre></td></tr></table></figure>

<h4 id="6-查询同个group-amp-topic下分区数量，分是否保存过offset分别处理"><a href="#6-查询同个group-amp-topic下分区数量，分是否保存过offset分别处理" class="headerlink" title="6. 查询同个group&amp;topic下分区数量，分是否保存过offset分别处理"></a>6. 查询同个group&amp;topic下分区数量，分是否保存过offset分别处理</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询该路径下是否子节点（默认有字节点为我们自己保存不同 partition 时生成的）</span></span><br><span class="line"><span class="comment">// /g001/offsets/wordcount/0/10001"  --&gt; 0号分区/偏移量10001</span></span><br><span class="line"><span class="comment">// /g001/offsets/wordcount/1/30001"  ...</span></span><br><span class="line"><span class="comment">// /g001/offsets/wordcount/2/10001"  ...</span></span><br><span class="line"><span class="comment">//zkTopicPath  -&gt; /g001/offsets/wordcount/</span></span><br><span class="line"><span class="keyword">val</span> children = zkClient.countChildren(zkTopicPath)<span class="comment">//返回分区数量</span></span><br></pre></td></tr></table></figure>

<h4 id="7-调用KafkaUtils-createDirectStream创建kafkaStream"><a href="#7-调用KafkaUtils-createDirectStream创建kafkaStream" class="headerlink" title="7. 调用KafkaUtils.createDirectStream创建kafkaStream"></a>7. 调用KafkaUtils.createDirectStream创建kafkaStream</h4><ul>
<li><p>如存在偏移量</p>
<ol>
<li>取出偏移量存入之前创建的保存偏移量的参数(fromOffsets)中</li>
<li>创建函数将MessageAndMetadata[String, String]取出message转成tupple类型</li>
<li>调用createDirectStream，传入ssc、kafka参数、fromOffsets、和MessageAndMetadata函数</li>
</ol>
</li>
<li><p>未存在偏移量</p>
<ol>
<li><p>直接调用createDirectStream，传入ssc、kafka参数、和topics  (Set[String]类型) </p>
<p>注：可能因为fromOffsets: Map[TopicAndPartition, Long]存在topic信息所以不用传topics了</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果保存过 offset</span></span><br><span class="line"><span class="keyword">if</span> (children &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until children) &#123;</span><br><span class="line">    <span class="comment">// 假如存在偏移量保存路径：/g001/offsets/wordcount/0/10001</span></span><br><span class="line">    <span class="comment">// $zkTopicPath/$&#123;i&#125;:g001/offsets/wordcount/0</span></span><br><span class="line">	<span class="comment">// partitionOffset:10001</span></span><br><span class="line">    <span class="keyword">val</span> partitionOffset = zkClient.readData[<span class="type">String</span>](<span class="string">s"<span class="subst">$zkTopicPath</span>/<span class="subst">$&#123;i&#125;</span>"</span>)</span><br><span class="line">    <span class="comment">// wordcount/0</span></span><br><span class="line">    <span class="keyword">val</span> tp = <span class="type">TopicAndPartition</span>(topic, i)</span><br><span class="line">    <span class="comment">//将不同 partition 对应的 offset 增加到 fromOffsets 中</span></span><br><span class="line">    <span class="comment">// wordcount/0 -&gt; 10001</span></span><br><span class="line">    fromOffsets += (tp -&gt; partitionOffset.toLong)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Key: kafka的key   values: "hello tom hello jerry"</span></span><br><span class="line">  <span class="comment">//这个会将 kafka 的消息进行 transform，最终 kafak 的数据都会变成 (kafka的key, message) 这样的 tuple，也可以用（mmd.topic(), mmd.message()）获得topic,value这样的数据</span></span><br><span class="line">  <span class="keyword">val</span> messageHandler = (mmd: <span class="type">MessageAndMetadata</span>[<span class="type">String</span>, <span class="type">String</span>]) =&gt; (mmd.key(), mmd.message())																</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//通过KafkaUtils创建直连的DStream（fromOffsets参数的作用是:按照前面计算好了的偏移量继续消费数据）</span></span><br><span class="line">  <span class="comment">//[String, String, StringDecoder, StringDecoder,     (String, String)]</span></span><br><span class="line">  <span class="comment">//  key    value    key的解码方式   value的解码方式 </span></span><br><span class="line">  kafkaStream = <span class="type">KafkaUtils</span>.createDirectStream[<span class="type">String</span>, <span class="type">String</span>, <span class="type">StringDecoder</span>, <span class="type">StringDecoder</span>, (<span class="type">String</span>, <span class="type">String</span>)](ssc, kafkaParams, fromOffsets, messageHandler)</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//如果未保存，根据 kafkaParam 的配置使用最新(largest)或者最旧的（smallest） offset</span></span><br><span class="line">  kafkaStream = <span class="type">KafkaUtils</span>.createDirectStream[<span class="type">String</span>, <span class="type">String</span>, <span class="type">StringDecoder</span>, <span class="type">StringDecoder</span>](ssc, kafkaParams, topics)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-定义保存偏移量范围的变量"><a href="#8-定义保存偏移量范围的变量" class="headerlink" title="8. 定义保存偏移量范围的变量"></a>8. 定义保存<strong>偏移量范围</strong>的变量</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//偏移量的范围</span></span><br><span class="line"><span class="keyword">var</span> offsetRanges = <span class="type">Array</span>[<span class="type">OffsetRange</span>]()</span><br></pre></td></tr></table></figure>

<h4 id="9-调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存"><a href="#9-调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存" class="headerlink" title="9. 调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存"></a>9. 调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从kafka读取的消息，DStream的Transform方法可以将当前批次的RDD获取出来</span></span><br><span class="line"><span class="comment">//该transform方法计算获取到当前批次RDD,然后将RDD的偏移量取出来，然后在将RDD返回到DStream</span></span><br><span class="line"><span class="keyword">val</span> transform: <span class="type">DStream</span>[(<span class="type">String</span>, <span class="type">String</span>)] = kafkaStream.transform &#123; rdd =&gt;</span><br><span class="line">  <span class="comment">//得到该 rdd 对应 kafka 的消息的 offset</span></span><br><span class="line">  <span class="comment">//该RDD是一个KafkaRDD，可以获得偏移量的范围</span></span><br><span class="line">  offsetRanges = rdd.asInstanceOf[<span class="type">HasOffsetRanges</span>].offsetRanges</span><br><span class="line">  rdd<span class="comment">//将原kafkaStream原封返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-只获取kafkaStream中的message"><a href="#10-只获取kafkaStream中的message" class="headerlink" title="10. 只获取kafkaStream中的message"></a>10. 只获取kafkaStream中的message</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> messages: <span class="type">DStream</span>[<span class="type">String</span>] = transform.map(_._2)</span><br></pre></td></tr></table></figure>

<h4 id="11-对DStream调用foreachRDD进行操作每个RDD流"><a href="#11-对DStream调用foreachRDD进行操作每个RDD流" class="headerlink" title="11. 对DStream调用foreachRDD进行操作每个RDD流"></a>11. 对DStream调用foreachRDD进行操作每个RDD流</h4><ul>
<li><h4 id="将偏移量保存到zookeeper的gropu-offset-topic-partition路径下"><a href="#将偏移量保存到zookeeper的gropu-offset-topic-partition路径下" class="headerlink" title="将偏移量保存到zookeeper的gropu/offset/topic/partition路径下"></a>将偏移量保存到zookeeper的gropu/offset/topic/partition路径下</h4></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依次迭代DStream中的RDD</span></span><br><span class="line"><span class="comment">//注意!：kafkaStream.foreachRDD里面的业务逻辑是在Driver端执行、kafkaRDD.maps里定义的方法才是在Excutor里执行，maps方法是在Driver端执行</span></span><br><span class="line"><span class="comment">//foreachRDD只是把每个RDD拿出来，没有触发Action</span></span><br><span class="line">messages.foreachRDD &#123; rdd =&gt;</span><br><span class="line">  <span class="comment">//对RDD进行操作，触发Action</span></span><br><span class="line">  rdd.foreachPartition(partition =&gt;</span><br><span class="line">    partition.foreach(x =&gt; &#123;</span><br><span class="line">      println(x)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (o &lt;- offsetRanges) &#123;</span><br><span class="line">    <span class="comment">//  /g001/offsets/wordcount/0</span></span><br><span class="line">    <span class="keyword">val</span> zkPath = <span class="string">s"<span class="subst">$&#123;topicDirs.consumerOffsetDir&#125;</span>/<span class="subst">$&#123;o.partition&#125;</span>"</span></span><br><span class="line">    <span class="comment">//将该 partition 的 offset 保存到 zookeeper</span></span><br><span class="line">    <span class="comment">//  /g001/offsets/wordcount/0/20000（untilOffset是截至的偏移量）</span></span><br><span class="line">    <span class="type">ZkUtils</span>.updatePersistentPath(zkClient, zkPath, o.untilOffset.toString)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-SparkStreaming程序启动和退出"><a href="#12-SparkStreaming程序启动和退出" class="headerlink" title="12. SparkStreaming程序启动和退出"></a>12. SparkStreaming程序启动和退出</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssc.start()</span><br><span class="line">ssc.awaitTermination()</span><br></pre></td></tr></table></figure>

<p><strong>备注</strong>：也可以在kafkaStream.foreachRDD中对kafkaRDD强转获取到偏移量（只能对kafkaRDD进行强转）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直连方式只有在KafkaDStream的RDD中才能获取偏移量，那么就不能再调用DStream的Transformation</span></span><br><span class="line"><span class="comment">//所以只能在kafkaStream调用foreachRDD，获取RDD的偏移量，然后就是对RDD进行操作了</span></span><br><span class="line"><span class="comment">//依次迭代KafkaDStream中的KafkaRDD</span></span><br><span class="line">kafkaStream.foreachRDD &#123; kafkaRDD =&gt;</span><br><span class="line">  <span class="comment">//只有KafkaRDD可以强转成HasOffsetRanges，并获取到偏移量</span></span><br><span class="line">  offsetRanges = kafkaRDD.asInstanceOf[<span class="type">HasOffsetRanges</span>].offsetRanges</span><br><span class="line">  <span class="keyword">val</span> lines: <span class="type">RDD</span>[<span class="type">String</span>] = kafkaRDD.map(_._2)</span><br></pre></td></tr></table></figure>

<h4 id="13-补充：kafka直连方式消费多个topic"><a href="#13-补充：kafka直连方式消费多个topic" class="headerlink" title="13. 补充：kafka直连方式消费多个topic"></a>13. 补充：<a href="https://blog.csdn.net/Lu_Xiao_Yue/article/details/84075565" target="_blank" rel="noopener">kafka直连方式消费多个topic</a></h4><h4 id="Kafka知识补充"><a href="#Kafka知识补充" class="headerlink" title="Kafka知识补充"></a>Kafka知识补充</h4><h5 id="1-Kafka分区"><a href="#1-Kafka分区" class="headerlink" title="1. Kafka分区"></a>1. Kafka分区</h5><ul>
<li>0、1、2代表数据的不同分区</li>
<li>0`、1`、2`代表不同的副本</li>
<li>生产者向一个leader分区发送数据，消费者也向leader分区消费数据（可以配置消费者向非leader分区消费）</li>
<li>数据的分区数量可以任意，副本数量不大于启动kafka机器的数量<br><img src="//yoursite.com/2019/07/24/sparkStreaming学习总结/sparkStreaming%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%5Ckafka%E5%88%86%E5%8C%BA%E5%8E%9F%E7%90%86.png" alt="Kafka分区原理"></li>
</ul>
<img src="/2019/07/24/sparkStreaming学习总结/kafka分区原理.png">

<h5 id="2-kafka直连"><a href="#2-kafka直连" class="headerlink" title="2. kafka直连"></a>2. kafka直连</h5><p>Direct方式采用Kafka简单的consumer api方式来读取数据，无需经由ZooKeeper，此种方式不再需要专门Receiver来持续不断读取数据。当batch任务触发时，由Executor读取数据，并参与到其他Executor的数据计算过程中去。driver来决定读取多少offsets，并将offsets交由checkpoints来维护。将触发下次batch任务，再由Executor读取Kafka数据并计算。从此过程我们可以发现Direct方式无需Receiver读取数据，而是需要计算时再读取数据，所以Direct方式的数据消费对内存的要求不高，只需要考虑批量计算所需要的内存即可；另外batch任务堆积时，也不会影响数据堆积。其具体读取方式如下图：</p>
<p>Receiver方式：<img src="//yoursite.com/2019/07/24/sparkStreaming学习总结/sparkStreaming%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%5CReceiver%E6%96%B9%E5%BC%8F.png" alt="Receiver方式"></p>
<img src="/2019/07/24/sparkStreaming学习总结/Receiver方式.png">





<p>直连方式：<img src="//yoursite.com/2019/07/24/sparkStreaming学习总结/sparkStreaming%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%5C%E7%9B%B4%E8%BF%9E%E6%96%B9%E5%BC%8F.png" alt="直连方式"></p>
<img src="/2019/07/24/sparkStreaming学习总结/直连方式.png">



<h3 id="直连方式-SparkStreaming-kafka-0-10"><a href="#直连方式-SparkStreaming-kafka-0-10" class="headerlink" title="直连方式-SparkStreaming-kafka-0.10"></a>直连方式-SparkStreaming-kafka-0.10</h3><h4 id="1-创建StreamingContxt（用sparkConf）-1"><a href="#1-创建StreamingContxt（用sparkConf）-1" class="headerlink" title="1. 创建StreamingContxt（用sparkConf）"></a>1. 创建StreamingContxt（用sparkConf）</h4><h4 id="2-Kafka参数配置-1"><a href="#2-Kafka参数配置-1" class="headerlink" title="2. Kafka参数配置"></a>2. Kafka参数配置</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> topics = <span class="type">Array</span>(topic)	<span class="comment">//数组方式保存topics</span></span><br><span class="line"><span class="keyword">val</span> kafkaParams = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Object</span>](</span><br><span class="line">    <span class="comment">//即0.8版的broker-list</span></span><br><span class="line">   <span class="string">"bootstrap.servers"</span> -&gt; <span class="string">"node-1:9092,node-2:9092,node-3:9092"</span>,</span><br><span class="line">   <span class="string">"key.deserializer"</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">   <span class="string">"value.deserializer"</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">   <span class="string">"group.id"</span> -&gt; group,</span><br><span class="line">   <span class="string">"auto.offset.reset"</span> -&gt; <span class="string">"earliest"</span>, <span class="comment">// lastest</span></span><br><span class="line">   <span class="string">"enable.auto.commit"</span> -&gt; (<span class="literal">false</span>: java.lang.<span class="type">Boolean</span>) <span class="comment">// false代表自己写程序提交偏移量 </span></span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<h4 id="3-创建SparkDStream-一个API"><a href="#3-创建SparkDStream-一个API" class="headerlink" title="3. 创建SparkDStream(一个API)"></a>3. 创建SparkDStream(一个API)</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用直连方式读取kafka中的数据，在Kafka中记录读取偏移量</span></span><br><span class="line"><span class="comment">//spark-kafka-0.8把偏移量保存在zookeeper里，也可存在redis等里</span></span><br><span class="line"><span class="keyword">val</span> stream = <span class="type">KafkaUtils</span>.createDirectStream[<span class="type">String</span>, <span class="type">String</span>](</span><br><span class="line">  streamingContext,</span><br><span class="line">  <span class="comment">//位置策略（如果kafka和spark程序部署在一起，会有最优位置）</span></span><br><span class="line">  <span class="type">PreferConsistent</span>,</span><br><span class="line">  <span class="comment">//订阅的策略（可以指定用正则的方式读取topic，比如my-ordsers-.*）</span></span><br><span class="line">  <span class="type">Subscribe</span>[<span class="type">String</span>, <span class="type">String</span>](topics, kafkaParams)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="4-获取跟新偏移量，操作DStream"><a href="#4-获取跟新偏移量，操作DStream" class="headerlink" title="4. 获取跟新偏移量，操作DStream"></a>4. 获取跟新偏移量，操作DStream</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代DStream中的RDD，将每一个时间点对于的RDD拿出来</span></span><br><span class="line">stream.foreachRDD &#123; rdd =&gt;</span><br><span class="line">  <span class="keyword">if</span>(!rdd.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">//获取该RDD对于的偏移量</span></span><br><span class="line">    <span class="keyword">val</span> offsetRanges = rdd.asInstanceOf[<span class="type">HasOffsetRanges</span>].offsetRanges</span><br><span class="line">	<span class="comment">//拿出对于的数据，foreach是一个aciton</span></span><br><span class="line">    rdd.foreach&#123; line =&gt;</span><br><span class="line">		<span class="comment">//Kafka在消费偏移量之后的数据不一定按顺序进行消费（因为有多个Consumer同时进行消费）</span></span><br><span class="line">		println(line.key() + <span class="string">" "</span> + line.value())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新偏移量</span></span><br><span class="line">    <span class="comment">// some time later, after outputs have completed</span></span><br><span class="line">    stream.asInstanceOf[<span class="type">CanCommitOffsets</span>].commitAsync(offsetRanges)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-SparkStreaming程序启动和退出"><a href="#5-SparkStreaming程序启动和退出" class="headerlink" title="5. SparkStreaming程序启动和退出"></a>5. SparkStreaming程序启动和退出</h4><h3 id="订单项目示例（离线和实时）-非常重要"><a href="#订单项目示例（离线和实时）-非常重要" class="headerlink" title="订单项目示例（离线和实时）*非常重要*"></a>订单项目示例（离线和实时）*非常重要*</h3><p>数据：A 202.106.196.115 手机 iPhone8 8000</p>
<h4 id="0-用到的工具类（Object）："><a href="#0-用到的工具类（Object）：" class="headerlink" title="0. 用到的工具类（Object）："></a>0. 用到的工具类（Object）：</h4><ul>
<li>离线计算 IP-地址 规则</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">broadcastIpRules</span></span>(ssc: <span class="type">StreamingContext</span>, ipRulesPath: <span class="type">String</span>): <span class="type">Broadcast</span>[<span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)]] = &#123;</span><br><span class="line">  <span class="comment">//现获取sparkContext</span></span><br><span class="line">  <span class="keyword">val</span> sc = ssc.sparkContext</span><br><span class="line">  <span class="keyword">val</span> rulesLines:<span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(ipRulesPath)</span><br><span class="line">  <span class="comment">//整理ip规则数据</span></span><br><span class="line">  <span class="keyword">val</span> ipRulesRDD: <span class="type">RDD</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)] = rulesLines.map(line =&gt; &#123;</span><br><span class="line"> 	...</span><br><span class="line">    (startNum, endNum, province)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//将分散在多个Executor中的部分IP规则收集到Driver端</span></span><br><span class="line">  <span class="keyword">val</span> rulesInDriver: <span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)] = ipRulesRDD.collect()</span><br><span class="line">  <span class="comment">//将Driver端的数据广播到Executor</span></span><br><span class="line">  <span class="comment">//广播变量的引用（还在Driver端）</span></span><br><span class="line">  sc.broadcast(rulesInDriver)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>计算成交总金额（一个批次收入存入Redis，流数据不断累加）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateIncome</span></span>(fields: <span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">String</span>]]) = &#123;</span><br><span class="line">  <span class="comment">//将数据计算后写入到Reids</span></span><br><span class="line">  <span class="keyword">val</span> priceRDD: <span class="type">RDD</span>[<span class="type">Double</span>] = fields.map(arr =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> price = arr(<span class="number">4</span>).toDouble</span><br><span class="line">    price</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//reduce是一个Action，会把结果返回到Driver端</span></span><br><span class="line">  <span class="comment">//将当前批次的总金额返回了</span></span><br><span class="line">  <span class="keyword">val</span> sum: <span class="type">Double</span> = priceRDD.reduce(_+_)</span><br><span class="line">  <span class="comment">//获取一个jedis连接（在Driver端创建）</span></span><br><span class="line">  <span class="keyword">val</span> conn = <span class="type">JedisConnectionPool</span>.getConnection()</span><br><span class="line">  <span class="comment">//将历史值和当前的值进行累加</span></span><br><span class="line">  <span class="comment">//conn.set(Constant.TOTAL_INCOME, sum.toString)</span></span><br><span class="line">  conn.incrByFloat(<span class="type">Constant</span>.<span class="type">TOTAL_INCOME</span>, sum)</span><br><span class="line">  <span class="comment">//释放连接</span></span><br><span class="line">  conn.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>计算商品分类成交总金额（一个批次收入存入Redis，流数据不断累加）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateItem</span></span>(fields: <span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">String</span>]]) = &#123;</span><br><span class="line">  <span class="comment">//备注：对field的map方法是在哪一端调用的呢？Driver，只是map里面的方法还没执行</span></span><br><span class="line">  <span class="keyword">val</span> itemAndPrice: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = fields.map(arr =&gt; &#123;</span><br><span class="line">    <span class="comment">//分类</span></span><br><span class="line">    <span class="keyword">val</span> item = arr(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">//金额</span></span><br><span class="line">    <span class="keyword">val</span> parice = arr(<span class="number">4</span>).toDouble</span><br><span class="line">    (item, parice)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//按照商品分类进行聚合</span></span><br><span class="line">  <span class="keyword">val</span> reduced: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = itemAndPrice.reduceByKey(_+_)</span><br><span class="line">  <span class="comment">//将当前批次的数据累加到Redis中</span></span><br><span class="line">  <span class="comment">//foreachPartition是一个Action</span></span><br><span class="line">  <span class="comment">//现在这种方式，jeids的连接是在哪一端创建的（Driver）</span></span><br><span class="line">  <span class="comment">//在Driver端拿Jedis连接不好(要序列化)</span></span><br><span class="line">  <span class="comment">//val conn = JedisConnectionPool.getConnection()</span></span><br><span class="line">  reduced.foreachPartition(part =&gt; &#123;</span><br><span class="line">    <span class="comment">//获取一个Jedis连接</span></span><br><span class="line">    <span class="comment">//这个连接其实是在Executor中的获取的</span></span><br><span class="line">    <span class="comment">//JedisConnectionPool在一个Executor进程中只有1个实例（单例）</span></span><br><span class="line">    <span class="keyword">val</span> conn = <span class="type">JedisConnectionPool</span>.getConnection()</span><br><span class="line">    part.foreach(t =&gt; &#123;</span><br><span class="line">      <span class="comment">//一个连接更新多条数据</span></span><br><span class="line">      conn.incrByFloat(t._1, t._2)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//将当前分区中的数据跟新完在关闭连接</span></span><br><span class="line">    conn.close()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>计算省份成交总金额（一个批次收入存入Redis，流数据不断累加）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateZone</span></span>(fields: <span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">String</span>]], broadcastRef: <span class="type">Broadcast</span>[<span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)]]) = &#123;</span><br><span class="line">  <span class="keyword">val</span> provinceAndPrice: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = fields.map(arr =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> ip = arr(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> price = arr(<span class="number">4</span>).toDouble</span><br><span class="line">    <span class="keyword">val</span> ipNum = <span class="type">MyUtils</span>.ip2Long(ip)</span><br><span class="line">    <span class="comment">//在Executor中获取到广播的全部规则</span></span><br><span class="line">    <span class="keyword">val</span> allRules: <span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)] = broadcastRef.value</span><br><span class="line">    <span class="comment">//二分法查找,根据Ip计算归属地</span></span><br><span class="line">    <span class="keyword">val</span> index = <span class="type">MyUtils</span>.binarySearch(allRules, ipNum)</span><br><span class="line">    <span class="keyword">var</span> province = <span class="string">"未知"</span></span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">      province = allRules(index)._3</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省份，订单金额</span></span><br><span class="line">    (province, price)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//按省份进行聚合</span></span><br><span class="line">  <span class="keyword">val</span> reduced: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = provinceAndPrice.reduceByKey(_+_)</span><br><span class="line">  <span class="comment">//将数据跟新到Redis</span></span><br><span class="line"><span class="comment">//key不多的话可以用.foreach</span></span><br><span class="line">  reduced.foreachPartition(part =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> conn = <span class="type">JedisConnectionPool</span>.getConnection()</span><br><span class="line">    part.foreach(t =&gt; &#123;</span><br><span class="line">      conn.incrByFloat(t._1, t._2)</span><br><span class="line">    &#125;)</span><br><span class="line">    conn.close()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-创建StreamingContxt（用sparkConf）-2"><a href="#1-创建StreamingContxt（用sparkConf）-2" class="headerlink" title="1. 创建StreamingContxt（用sparkConf）"></a>1. 创建StreamingContxt（用sparkConf）</h4><h4 id="2-广播离线计算的-IP-地址-规则"><a href="#2-广播离线计算的-IP-地址-规则" class="headerlink" title="*2. *广播离线计算的 IP-地址 规则**"></a>*<em>2. *</em>广播离线计算的 IP-地址 规则**</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> broadcastRef: <span class="type">Broadcast</span>[<span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)]] = <span class="type">IPUtils</span>.broadcastIpRules(ssc, <span class="string">"/Users/zx/Desktop/temp/spark-24/spark-4/ip/ip.txt"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-Kafka参数配置"><a href="#3-Kafka参数配置" class="headerlink" title="3. Kafka参数配置"></a>3. Kafka参数配置</h4><h4 id="4-创建zookeeper偏移量保存路径"><a href="#4-创建zookeeper偏移量保存路径" class="headerlink" title="4. 创建zookeeper偏移量保存路径"></a>4. 创建zookeeper偏移量保存路径</h4><h4 id="5-创建zookeeper客户端"><a href="#5-创建zookeeper客户端" class="headerlink" title="5. 创建zookeeper客户端"></a>5. 创建zookeeper客户端</h4><h4 id="6-定义保存kafkaSteam和偏移量的变量"><a href="#6-定义保存kafkaSteam和偏移量的变量" class="headerlink" title="6. 定义保存kafkaSteam和偏移量的变量"></a>6. 定义保存<strong>kafkaSteam</strong>和<strong>偏移量</strong>的变量</h4><h4 id="7-查询同个group-amp-topic下分区数量，分是否保存过offset分别处理"><a href="#7-查询同个group-amp-topic下分区数量，分是否保存过offset分别处理" class="headerlink" title="7. 查询同个group&amp;topic下分区数量，分是否保存过offset分别处理"></a>7. 查询同个group&amp;topic下分区数量，分是否保存过offset分别处理</h4><h4 id="8-调用KafkaUtils-createDirectStream创建kafkaStream"><a href="#8-调用KafkaUtils-createDirectStream创建kafkaStream" class="headerlink" title="8. 调用KafkaUtils.createDirectStream创建kafkaStream"></a>8. 调用KafkaUtils.createDirectStream创建kafkaStream</h4><h4 id="9-定义保存偏移量范围的变量"><a href="#9-定义保存偏移量范围的变量" class="headerlink" title="9. 定义保存偏移量范围的变量"></a>9. 定义保存<strong>偏移量范围</strong>的变量</h4><h4 id="10-调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存"><a href="#10-调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存" class="headerlink" title="10. 调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存"></a>10. 调用DStream的transform方法将kafkaStream强转成HasOffsetRanges，获取偏移量范围信息并保存</h4><h4 id="11-只获取kafkaStream中的message"><a href="#11-只获取kafkaStream中的message" class="headerlink" title="11. 只获取kafkaStream中的message"></a>11. 只获取kafkaStream中的message</h4><h4 id="12-对DStream调用foreachRDD进行操作每个RDD流"><a href="#12-对DStream调用foreachRDD进行操作每个RDD流" class="headerlink" title="***12. 对DStream调用foreachRDD进行操作每个RDD流"></a>***12. 对DStream调用foreachRDD进行操作每个RDD流</h4><ul>
<li><h4 id="将偏移量保存到zookeeper的gropu-offset-topic-partition路径下-1"><a href="#将偏移量保存到zookeeper的gropu-offset-topic-partition路径下-1" class="headerlink" title="将偏移量保存到zookeeper的gropu/offset/topic/partition路径下"></a>将偏移量保存到zookeeper的gropu/offset/topic/partition路径下</h4></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意!：kafkaStream.foreachRDD里面的业务逻辑是在Driver端执行、kafkaRDD.maps是在Excutor里执行</span></span><br><span class="line">kafkaStream.foreachRDD &#123; kafkaRDD =&gt;</span><br><span class="line">  <span class="comment">//判断当前的kafkaStream中的RDD是否有数据</span></span><br><span class="line">  <span class="comment">//注意！！！！！kafkaRDD为空下面的map方法就不能执行（容易踩坑点）</span></span><br><span class="line">  <span class="keyword">if</span>(!kafkaRDD.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">//只有KafkaRDD可以强转成HasOffsetRanges，并获取到偏移量</span></span><br><span class="line">    <span class="comment">//offsetRanges = kafkaRDD.asInstanceOf[HasOffsetRanges].offsetRanges</span></span><br><span class="line">    <span class="comment">//				备注：=============================&gt;在这里获取偏移量范围取代第10步操作</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//val lines: RDD[String] = kafkaRDD.map(_._2)</span></span><br><span class="line">	<span class="comment">//				备注：================&gt;在这里获取kafkaStream中的message取代第11步操作</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//整理数据</span></span><br><span class="line">	<span class="comment">//备注：RDD在Driver端生成,但里面函数没执行，可以把RDD引用传递给方法</span></span><br><span class="line">    <span class="keyword">val</span> fields: <span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">String</span>]] = lines.map(_.split(<span class="string">" "</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//流式数据在这些定义的方法里不断经过处理，计算结果保存到Redis中</span></span><br><span class="line">    <span class="comment">//计算成交总金额</span></span><br><span class="line">    <span class="type">CalculateUtil</span>.calculateIncome(fields)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算商品分类金额</span></span><br><span class="line">    <span class="type">CalculateUtil</span>.calculateItem(fields)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算区域成交金额</span></span><br><span class="line">    <span class="type">CalculateUtil</span>.calculateZone(fields, broadcastRef)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//偏移量更新在哪一端（Driver）</span></span><br><span class="line">    <span class="keyword">for</span> (o &lt;- offsetRanges) &#123;</span><br><span class="line">      <span class="comment">//  /g001/offsets/wordcount/0</span></span><br><span class="line">      <span class="keyword">val</span> zkPath = <span class="string">s"<span class="subst">$&#123;topicDirs.consumerOffsetDir&#125;</span>/<span class="subst">$&#123;o.partition&#125;</span>"</span></span><br><span class="line">      <span class="comment">//将该 partition 的 offset 保存到 zookeeper</span></span><br><span class="line">      <span class="comment">//  /g001/offsets/wordcount/0/20000</span></span><br><span class="line">      <span class="type">ZkUtils</span>.updatePersistentPath(zkClient, zkPath, o.untilOffset.toString)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-SparkStreaming程序启动和退出"><a href="#13-SparkStreaming程序启动和退出" class="headerlink" title="13. SparkStreaming程序启动和退出"></a>13. SparkStreaming程序启动和退出</h4><h3 id="直接监听Socket"><a href="#直接监听Socket" class="headerlink" title="直接监听Socket"></a>直接监听Socket</h3><p>在Linux上用yum安装nc    yum install -y nc</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程数量必须要两个以上</span></span><br><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"SteamingWordCount"</span>).setMaster(<span class="string">"local[2]"</span>) </span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"><span class="comment">//StreamingContext是对SparkContext的包装，包了一层就增加了实时的功能</span></span><br><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sc, <span class="type">Milliseconds</span>(<span class="number">5000</span>))</span><br><span class="line"><span class="comment">//有了StreamingContext，就可以创建SparkStreaming的抽象了DSteam</span></span><br><span class="line"><span class="comment">//从一个socket端口中读取数据</span></span><br><span class="line"><span class="keyword">val</span> lines: <span class="type">ReceiverInputDStream</span>[<span class="type">String</span>] = ssc.socketTextStream(<span class="string">"192.168.1.207"</span>, <span class="number">8888</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Spark-On-Yarn"><a href="#Spark-On-Yarn" class="headerlink" title="Spark On Yarn"></a>Spark On Yarn</h2><p><a href="sparkStreaming学习总结/spark-on-yarn.docx">详见文档</a></p>
<ol>
<li><p>环境</p>
<ul>
<li><p>安装hadoop：需要安装HDFS模块和YARN模块，HDFS必须安装，spark运行时要把jar包存放到HDFS上。</p>
</li>
<li><p>安装Spark：解压Spark安装程序到一台服务器上，修改spark-env.sh配置文件，spark程序将作为YARN的客户端用于提交任务</p>
<p>Tips：或者把HADOOP_CONF_DIR在/etc/profile里配置</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.8.0_131</span><br><span class="line">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/Hadoop</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>提交任务</p>
<ul>
<li><strong>cluster模式</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit --class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master yarn \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--driver-memory 1g \</span><br><span class="line">--executor-memory 1g \</span><br><span class="line">--executor-cores 2 \</span><br><span class="line">--queue default \  			#默认资源调度器</span><br><span class="line">lib/spark-examples*.jar \</span><br><span class="line">10						#参数</span><br></pre></td></tr></table></figure>

<ul>
<li><p>client模式</p>
<p>修改$HADOOP_HOME /etc/hadoop所有yarn节点的yarn-site.xml，在该文件中添加如下配置</p>
<p>修改内存检测机制</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.pmem-check-enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.vmem-check-enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--deploy-mode client \ #其余不变</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>两种模式的区别</p>
<ul>
<li><p>cluster模式：Driver程序在YARN中运行，应用的运行结果不能在客户端显示，所以最好运行那些将结果最终保存在外部存储介质（如HDFS、Redis、Mysql）而非stdout输出的应用程序，客户端的终端显示的仅是作为YARN的job的简单运行状况。</p>
</li>
<li><p>client模式：Driver运行在Client上，应用程序运行结果会在客户端显示，所有适合运行结果有输出的应用程序（如spark-shell）</p>
</li>
</ul>
</li>
</ol>
<h2 id="DStream知识补充"><a href="#DStream知识补充" class="headerlink" title="DStream知识补充"></a>DStream知识补充</h2><p>Spark Streaming是一个基于Spark Core之上的实时计算框架，可以从很多数据源消费数据并对数据进行处理，在Spark Streaing中有一个最基本的抽象叫DStream（代理），本质上就是一系列连续的RDD，DStream其实就是对RDD的封装。DStream可以任务是一个RDD的工厂，该DStream里面生产都是相同业务逻辑的RDD，只不过是RDD里面要读取数据的不相同</p>
<p>深入理解DStream：他是sparkStreaming中的一个最基本的抽象，代表了一下列连续的数据流，本质上是一系列连续的RDD，你对DStream进行操作，就是对RDD进行操作。DStream每隔一段时间生成一个RDD，你对DStream进行操作，本质上是对里面的对应时间的RDD进行操作。</p>
<p>DSteam和DStream之间存在依赖关系，在一个固定的时间点，对个存在依赖关系的DSrteam对应的RDD也存在依赖关系，每个一个固定的时间，其实生产了一个小的DAG，周期性的将生成的小DAG提交到集群中运行。</p>
<p><img src="//yoursite.com/2019/07/24/sparkStreaming学习总结/DStream%E8%AF%B4%E6%98%8E.png" alt="DStream抽象表示图"></p>
<img src="/2019/07/24/sparkStreaming学习总结/DStream说明.png" title="DStream说明.png">


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/24/sparkSQL学习总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cilibili">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/sparkSQL学习总结/" itemprop="url">SparkSQL学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-24T11:31:41+08:00">
                2019-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spark/" itemprop="url" rel="index">
                    <span itemprop="name">spark</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SparkSQL"><a href="#SparkSQL" class="headerlink" title="SparkSQL"></a>SparkSQL</h1><h2 id="spark2-x"><a href="#spark2-x" class="headerlink" title="spark2.x"></a>spark2.x</h2><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><strong>首先在pom里导入spark sql的依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-sql_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spark.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-创建sparkSession"><a href="#1-创建sparkSession" class="headerlink" title="1.创建sparkSession"></a>1.创建sparkSession</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val spark = SparkSession.builder()</span><br><span class="line">      .appName(&quot;SQLTest1&quot;)</span><br><span class="line">      .master(&quot;local[*]&quot;)</span><br><span class="line">      .getOrCreate()</span><br></pre></td></tr></table></figure>

<h4 id="2-创建RDD，对RDD数据整理"><a href="#2-创建RDD，对RDD数据整理" class="headerlink" title="2.创建RDD，对RDD数据整理"></a>2.创建RDD，对RDD数据整理</h4><p>方法一：用sparkContext创建RDD，再处理RDD数据</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建RDD</span></span><br><span class="line"><span class="keyword">val</span> lines: <span class="type">RDD</span>[<span class="type">String</span>] = spark.sparkContext.textFile(<span class="string">"hdfs://node-4:9000/person"</span>)</span><br><span class="line"><span class="comment">//将数据进行整理</span></span><br><span class="line"><span class="keyword">val</span> rowRDD: <span class="type">RDD</span>[<span class="type">Row</span>] = lines.map(line =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">Row</span>(id, name, age, fv)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong>：用sparkSession直接创建DataSet[String] 类型，再用scalaAPI处理数据 （wordCount示例）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dataset分布式数据集，是对RDD的进一步封装，是更加智能的RDD</span></span><br><span class="line"><span class="comment">//dataset只有一列，默认这列叫value</span></span><br><span class="line"><span class="comment">//调用sparksession.read.textFile("..")返回的是DataSet，调用ss.textFile("..")返回的是RDD</span></span><br><span class="line"><span class="keyword">val</span> lines: <span class="type">Dataset</span>[<span class="type">String</span>] = spark.read.textFile(<span class="string">"hdfs://node-4:9000/words"</span>)</span><br></pre></td></tr></table></figure>

<p>DataSet处理数据</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整理数据(切分压平) wordCount</span></span><br><span class="line"><span class="comment">//DataSet调用了scala的API，需要导入隐式转换</span></span><br><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"><span class="keyword">val</span> words: <span class="type">Dataset</span>[<span class="type">String</span>] = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用DataSet的API（DSL）</span></span><br><span class="line"><span class="comment">//第一个count返回DataFrame（Transfomation），第二个count返回String（Action）</span></span><br><span class="line"><span class="keyword">val</span> r = words.groupBy($<span class="string">"value"</span> as <span class="string">"word"</span>).count().count()</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入聚合函数</span></span><br><span class="line"><span class="comment">//import org.apache.spark.sql.functions._</span></span><br><span class="line"><span class="comment">//val counts = words.groupBy($"value".as("word")).agg(count("*") as "counts").orderBy($"counts" desc)</span></span><br></pre></td></tr></table></figure>

<h4 id="3-创建schema信息"><a href="#3-创建schema信息" class="headerlink" title="3.创建schema信息"></a>3.创建schema信息</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结果类型，其实就是表头，用于描述DataFrame</span></span><br><span class="line"><span class="keyword">val</span> schema: <span class="type">StructType</span> = <span class="type">StructType</span>(<span class="type">List</span>(</span><br><span class="line">    <span class="type">StructField</span>(<span class="string">"id"</span>, <span class="type">LongType</span>, <span class="literal">true</span>),</span><br><span class="line">    <span class="type">StructField</span>(<span class="string">"name"</span>, <span class="type">StringType</span>, <span class="literal">true</span>),</span><br><span class="line">    <span class="type">StructField</span>(<span class="string">"age"</span>, <span class="type">IntegerType</span>, <span class="literal">true</span>),</span><br><span class="line">    <span class="type">StructField</span>(<span class="string">"fv"</span>, <span class="type">DoubleType</span>, <span class="literal">true</span>)</span><br><span class="line">))</span><br></pre></td></tr></table></figure>

<h4 id="4-创建DataFrame，关联schema信息"><a href="#4-创建DataFrame，关联schema信息" class="headerlink" title="4.创建DataFrame，关联schema信息"></a>4.创建DataFrame，关联schema信息</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建DataFrame</span></span><br><span class="line"><span class="keyword">val</span> df: <span class="type">DataFrame</span> = spark.createDataFrame(rowRDD, schema)</span><br></pre></td></tr></table></figure>

<h4 id="5-处理DataSet数据"><a href="#5-处理DataSet数据" class="headerlink" title="5.处理DataSet数据"></a>5.处理DataSet数据</h4><p>方法一：使用DataFrameAPI操作数据 （导入隐式函数）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"><span class="keyword">val</span> df2: <span class="type">Dataset</span>[<span class="type">Row</span>] = df.where($<span class="string">"fv"</span> &gt; <span class="number">98</span>).orderBy($<span class="string">"fv"</span> desc, $<span class="string">"age"</span> asc)</span><br></pre></td></tr></table></figure>

<p>方法二：使用SQL</p>
<h5 id="注册视图"><a href="#注册视图" class="headerlink" title="注册视图"></a>注册视图</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">words.createTempView(<span class="string">"v_wc"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="执行SQL（Transformation，lazy）"><a href="#执行SQL（Transformation，lazy）" class="headerlink" title="执行SQL（Transformation，lazy）"></a>执行SQL（Transformation，lazy）</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> result: <span class="type">DataFrame</span> = spark.sql(</span><br><span class="line">    <span class="string">"SELECT value word, COUNT(*) counts </span></span><br><span class="line"><span class="string">    FROM v_wc </span></span><br><span class="line"><span class="string">    GROUP BY word </span></span><br><span class="line"><span class="string">    ORDER BY counts DESC"</span>)</span><br><span class="line"><span class="comment">//执行Action</span></span><br><span class="line">result.show()	</span><br><span class="line"></span><br><span class="line"><span class="comment">//往其他存储软件里写 ==================================存疑=========================</span></span><br><span class="line">result.foreachPartition(iter:(<span class="type">Iterator</span>[<span class="type">Row</span>]) =&gt;&#123;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="6-关闭sparkSession连接"><a href="#6-关闭sparkSession连接" class="headerlink" title="6.关闭sparkSession连接"></a>6.关闭sparkSession连接</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark.stop()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="spark-join-连接表"><a href="#spark-join-连接表" class="headerlink" title="spark join 连接表"></a>spark join 连接表</h3><h4 id="1-创建两个DataFrame"><a href="#1-创建两个DataFrame" class="headerlink" title="1.创建两个DataFrame"></a>1.创建两个DataFrame</h4><ul>
<li>表1</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对Dataset进行RDD的操作要导入隐式转换  </span></span><br><span class="line"><span class="comment">//这里是spark是SparkSession的一个实例</span></span><br><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"><span class="keyword">val</span> lines: <span class="type">Dataset</span>[<span class="type">String</span>] = spark.createDataset(<span class="type">List</span>(<span class="string">"1,laozhoa,china"</span>, <span class="string">"2,laoduan,usa"</span>, <span class="string">"3,laoyang,jp"</span>))</span><br><span class="line"><span class="comment">//对数据进行整理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> tpDs: <span class="type">Dataset</span>[(<span class="type">Long</span>, <span class="type">String</span>, <span class="type">String</span>)] = lines.map(line =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> fields = line.split(<span class="string">","</span>)</span><br><span class="line">  <span class="keyword">val</span> id = fields(<span class="number">0</span>).toLong</span><br><span class="line">  <span class="keyword">val</span> name = fields(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">val</span> nationCode = fields(<span class="number">2</span>)</span><br><span class="line">  (id, name, nationCode)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">val</span> df1 = tpDs.toDF(<span class="string">"id"</span>, <span class="string">"name"</span>, <span class="string">"nation"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>表2</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> nations: <span class="type">Dataset</span>[<span class="type">String</span>] = spark.createDataset(<span class="type">List</span>(<span class="string">"china,中国"</span>, <span class="string">"usa,美国"</span>))</span><br><span class="line"><span class="comment">//对数据进行整理</span></span><br><span class="line"><span class="keyword">val</span> ndataset: <span class="type">Dataset</span>[(<span class="type">String</span>, <span class="type">String</span>)] = nations.map(l =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> fields = l.split(<span class="string">","</span>)</span><br><span class="line">  <span class="keyword">val</span> ename = fields(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">val</span> cname = fields(<span class="number">1</span>)</span><br><span class="line">  (ename, cname)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">val</span> df2 = ndataset.toDF(<span class="string">"ename"</span>,<span class="string">"cname"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-对两个DataFrame操作"><a href="#2-对两个DataFrame操作" class="headerlink" title="2.对两个DataFrame操作"></a>2.对两个DataFrame操作</h4><h5 id="方式一：SQL"><a href="#方式一：SQL" class="headerlink" title="方式一：SQL"></a>方式一：SQL</h5><p>1.创建两个视图（方式一：SQL）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1.createTempView(<span class="string">"v_users"</span>)</span><br><span class="line">df2.createTempView(<span class="string">"v_nations"</span>)</span><br></pre></td></tr></table></figure>

<p>2.写SQL</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> r: <span class="type">DataFrame</span> = spark.sql(</span><br><span class="line">    <span class="string">"SELECT name, cname </span></span><br><span class="line"><span class="string">    FROM v_users JOIN v_nations </span></span><br><span class="line"><span class="string">    ON nation = ename"</span>)</span><br><span class="line">r.show()</span><br></pre></td></tr></table></figure>

<h5 id="方式二：DataFrameAPI"><a href="#方式二：DataFrameAPI" class="headerlink" title="方式二：DataFrameAPI"></a>方式二：DataFrameAPI</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> r = df1.join(df2, $<span class="string">"nation"</span> === $<span class="string">"ename"</span>, <span class="string">"left_outer"</span>)</span><br><span class="line">r.show()</span><br></pre></td></tr></table></figure>

<h5 id="补充：三种spark-join-方式（详见博客）"><a href="#补充：三种spark-join-方式（详见博客）" class="headerlink" title="补充：三种spark join 方式（详见博客）"></a>补充：三种spark join 方式（<a href="https://www.cnblogs.com/duodushuduokanbao/p/9911256.html" target="_blank" rel="noopener">详见博客</a>）</h5><ol>
<li><p><strong>Broadcast Hash Join</strong>（大表与小表join）(spark默认join方式)</p>
<p>步骤：</p>
<ol>
<li>broadcast阶段：将小表广播到所有的executor上，广播的算法有很多，最简单的是先发给driver，driver再统一分发给所有的executor，要不就是基于bittorrete的p2p思路；</li>
<li>hash join阶段：在每个executor上执行 hash join，小表构建为hash table，大表的分区数据匹配hash table中的数据；</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result: <span class="type">DataFrame</span> = df1.join(df2, $<span class="string">"id"</span> === $<span class="string">"aid"</span>)</span><br><span class="line"><span class="keyword">val</span> result: <span class="type">DataFrame</span> = df1.join(broadcast(df2), $<span class="string">"id"</span> === $<span class="string">"aid"</span>)<span class="comment">//两者相同</span></span><br></pre></td></tr></table></figure>

<p>条件：</p>
<ul>
<li>被广播的表需要小于spark.sql.autoBroadcastJoinThreshold所配置的信息，默认是10M；</li>
<li>基表不能被广播，比如left outer join时，只能广播右表。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark.conf.set(<span class="string">"spark.sql.autoBroadcastJoinThreshold"</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>) <span class="comment">// 设置为10M</span></span><br></pre></td></tr></table></figure>

<p>先将小表在driver缓存内存，再broadCast，会对小表的扫描localTablesScan变为InMemoryScan</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df2.cache().count()</span><br><span class="line">df1.join(broadcast(df2), $<span class="string">"id"</span> === $<span class="string">"aid"</span>)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><strong>Shuffle Hash Join</strong>（大表与较小表join）</p>
<p>步骤：</p>
<ol>
<li>对两张表分别按照join key进行重分区(分区函数相同的时候，相同的相同分区中的key一定是相同的)，即shuffle，目的是为了让相同join key的记录分到对应的分区中；</li>
<li>对对应分区中的数据进行join，此处先将小表分区构建为一个hash表，然后根据大表中记录的join key的hash值拿来进行匹配，即每个节点山单独执行hash算法。</li>
</ol>
<p>条件：</p>
<ul>
<li><p>分区的平均大小不超过spark.sql.autoBroadcastJoinThreshold所配置的值，默认是10M </p>
</li>
<li><p>基表不能被广播，比如left outer join时，只能广播右表</p>
</li>
<li><p>一侧的表要明显小于另外一侧，小的一侧将被广播（明显小于的定义为3倍小，此处为经验值）</p>
</li>
</ul>
</li>
<li><p><strong>Sort Merge Join</strong>（两个大表进行join）</p>
<p>步骤：</p>
<ol>
<li><p>shuffle阶段：将两张大表根据join key进行重新分区，两张表数据会分布到整个集群，以便分布式并行处理；</p>
</li>
<li><p>sort阶段：对单个分区节点的两表数据，分别进行排序；</p>
</li>
<li><p>merge阶段：对排好序的两张分区表数据执行join操作。join操作很简单，分别遍历两个有序序列，碰到相同join key就merge输出，否则取更小一边</p>
</li>
</ol>
<p>条件：</p>
<ul>
<li>两个大表</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spark.conf.set(<span class="string">"spark.sql.join.preferSortMergeJoin"</span>, <span class="literal">true</span>)<span class="comment">//方法一</span></span><br><span class="line">spark.sql.autoBroadcastJoinThreshold=<span class="number">-1</span><span class="comment">//方法二</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<hr>
<h3 id="自定义函数-UDF、UDAF"><a href="#自定义函数-UDF、UDAF" class="headerlink" title="自定义函数 UDF、UDAF"></a>自定义函数 UDF、UDAF</h3><h4 id="UDF-（user-defined-function-1映射到1）"><a href="#UDF-（user-defined-function-1映射到1）" class="headerlink" title="UDF （user-defined function 1映射到1）"></a>UDF （user-defined function 1映射到1）</h4><ol>
<li>自定义函数并注册</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数的功能是（输入一个IP地址对应的十进制，返回一个省份名称）</span></span><br><span class="line">spark.udf.register(<span class="string">"ip2Province"</span>, (ipNum: <span class="type">Long</span>) =&gt; &#123; <span class="comment">//传入IP:Long数据</span></span><br><span class="line">      ...<span class="comment">//处理逻辑见 “统计IP示例”</span></span><br><span class="line">      province <span class="comment">//返回省份字符串</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark.sql(<span class="string">"SELECT ip2Province(ip_num) province FROM v_log "</span>).show()</span><br></pre></td></tr></table></figure>

<h4 id="UDAF-（user-defined-aggregate-function-n映射到1）"><a href="#UDAF-（user-defined-aggregate-function-n映射到1）" class="headerlink" title="UDAF （user-defined-aggregate function n映射到1）"></a>UDAF （user-defined-aggregate function n映射到1）</h4><h5 id="1-定义聚合函数"><a href="#1-定义聚合函数" class="headerlink" title="1. 定义聚合函数"></a>1. 定义聚合函数</h5><p>$$<br>函数功能：   \sqrt[n]{x_1<em>x_2</em>…*x_n}<br>$$</p>
<ul>
<li>继承UserDefinedAggregateFunction，实现8个方法</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeoMean</span> <span class="keyword">extends</span> <span class="title">UserDefinedAggregateFunction</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>输入数据的类型</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">inputSchema</span></span>: <span class="type">StructType</span> = <span class="type">StructType</span>(<span class="type">List</span>(</span><br><span class="line">  <span class="type">StructField</span>(<span class="string">"value"</span>, <span class="type">DoubleType</span>)</span><br><span class="line">))</span><br></pre></td></tr></table></figure>

<ul>
<li>产生中间结果的数据类型</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">bufferSchema</span></span>: <span class="type">StructType</span> = <span class="type">StructType</span>(<span class="type">List</span>(</span><br><span class="line">  <span class="comment">//相乘之后返回的积</span></span><br><span class="line">  <span class="type">StructField</span>(<span class="string">"product"</span>, <span class="type">DoubleType</span>),</span><br><span class="line">  <span class="comment">//参与运算数字的个数</span></span><br><span class="line">  <span class="type">StructField</span>(<span class="string">"counts"</span>, <span class="type">LongType</span>)</span><br><span class="line">))</span><br></pre></td></tr></table></figure>

<ul>
<li>最终返回的结果类型</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">dataType</span></span>: <span class="type">DataType</span> = <span class="type">DoubleType</span></span><br></pre></td></tr></table></figure>

<ul>
<li>确保一致性 一般用true</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">deterministic</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>指定初始值</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">//相乘的初始值</span></span><br><span class="line">  buffer(<span class="number">0</span>) = <span class="number">1.0</span></span><br><span class="line">  <span class="comment">//参与运算数字的个数的初始值</span></span><br><span class="line">  buffer(<span class="number">1</span>) = <span class="number">0</span>L</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每有一条数据参与运算就更新一下中间结果(update相当于在每一个分区中的运算)</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>, input: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">//每有一个数字参与运算就进行相乘（包含中间结果）</span></span><br><span class="line">  buffer(<span class="number">0</span>) = buffer.getDouble(<span class="number">0</span>) * input.getDouble(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">//参与运算数据的个数也有更新</span></span><br><span class="line">  buffer(<span class="number">1</span>) = buffer.getLong(<span class="number">1</span>) + <span class="number">1</span>L</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>全局聚合</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(buffer1: <span class="type">MutableAggregationBuffer</span>, buffer2: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">//每个分区计算的结果进行相乘</span></span><br><span class="line">  buffer1(<span class="number">0</span>) =  buffer1.getDouble(<span class="number">0</span>) * buffer2.getDouble(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">//每个分区参与预算的中间结果进行相加</span></span><br><span class="line">  buffer1(<span class="number">1</span>) =  buffer1.getLong(<span class="number">1</span>) + buffer2.getLong(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>计算最终的结果</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>(buffer: <span class="type">Row</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">  math.pow(buffer.getDouble(<span class="number">0</span>), <span class="number">1.</span>toDouble / buffer.getLong(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-调用聚合函数"><a href="#2-调用聚合函数" class="headerlink" title="2. 调用聚合函数"></a>2. 调用聚合函数</h5><ol>
<li>使用SQL</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> geomean = <span class="keyword">new</span> <span class="type">GeoMean</span></span><br><span class="line"><span class="keyword">val</span> range: <span class="type">Dataset</span>[<span class="type">Long</span>] = spark.range(<span class="number">1</span>, <span class="number">11</span>)<span class="comment">//定义1~11的单列数据</span></span><br><span class="line"><span class="comment">//注册函数</span></span><br><span class="line">spark.udf.register(<span class="string">"gm"</span>, geomean)</span><br><span class="line"><span class="comment">//将range这个Dataset[Long]注册成视图</span></span><br><span class="line">range.createTempView(<span class="string">"v_range"</span>)</span><br><span class="line"><span class="keyword">val</span> result = spark.sql(<span class="string">"SELECT gm(id) result FROM v_range"</span>)<span class="comment">//调用聚合函数</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DSL风格</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用DSL风格不用注册和建视图</span></span><br><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"><span class="keyword">val</span> result = range.groupBy().agg(geomean($<span class="string">"id"</span>).as(<span class="string">"geomean"</span>)) <span class="comment">//这里可以不用掉groupBy</span></span><br></pre></td></tr></table></figure>

<h4 id="UDTF"><a href="#UDTF" class="headerlink" title="UDTF"></a>UDTF</h4><p>输入一行，返回多行（hive）一对多    spark SQL中没有UDTF，spark中用flatMap即可实现该功能</p>
<h3 id="统计IP地址示例"><a href="#统计IP地址示例" class="headerlink" title="统计IP地址示例"></a>统计IP地址示例</h3><h4 id="初级版本：连接两张表查询"><a href="#初级版本：连接两张表查询" class="headerlink" title="初级版本：连接两张表查询"></a>初级版本：连接两张表查询</h4><ol>
<li>创建sparkSession</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">      .builder()</span><br><span class="line">      .appName(<span class="string">"JoinTest"</span>)</span><br><span class="line">      .master(<span class="string">"local[*]"</span>)</span><br><span class="line">      .getOrCreate()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建”IP-地区规则表”&amp;”IP记录表”的DataFrame</li>
</ol>
<ul>
<li>IP-地区规则表</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取到HDFS中的ip规则</span></span><br><span class="line"><span class="keyword">import</span> spark.implicits._                                   <span class="comment">//导入隐式参数因为用了Map方法</span></span><br><span class="line"><span class="keyword">val</span> rulesLines:<span class="type">Dataset</span>[<span class="type">String</span>] = spark.read.textFile(args(<span class="number">0</span>))</span><br><span class="line"><span class="comment">//整理ip规则数据()</span></span><br><span class="line"><span class="keyword">val</span> ruleDataFrame: <span class="type">DataFrame</span> = rulesLines.map(line =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> fields = line.split(<span class="string">"[|]"</span>)</span><br><span class="line">  <span class="keyword">val</span> startNum = fields(<span class="number">2</span>).toLong</span><br><span class="line">  <span class="keyword">val</span> endNum = fields(<span class="number">3</span>).toLong</span><br><span class="line">  <span class="keyword">val</span> province = fields(<span class="number">6</span>)</span><br><span class="line">  (startNum, endNum, province)</span><br><span class="line">&#125;).toDF(<span class="string">"snum"</span>, <span class="string">"enum"</span>, <span class="string">"province"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>IP记录表</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建RDD，读取ip访问日志</span></span><br><span class="line"><span class="keyword">val</span> accessLines: <span class="type">Dataset</span>[<span class="type">String</span>] = spark.read.textFile(args(<span class="number">1</span>))</span><br><span class="line"><span class="comment">//整理数据</span></span><br><span class="line"><span class="keyword">val</span> ipDataFrame: <span class="type">DataFrame</span> = accessLines.map(log =&gt; &#123;</span><br><span class="line">  <span class="comment">//将log日志的每一行进行切分</span></span><br><span class="line">  <span class="keyword">val</span> fields = log.split(<span class="string">"[|]"</span>)</span><br><span class="line">  <span class="keyword">val</span> ip = fields(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">//将ip转换成十进制</span></span><br><span class="line">  <span class="keyword">val</span> ipNum = <span class="type">MyUtils</span>.ip2Long(ip) <span class="comment">//将111.11.11.11整理成Long型数据</span></span><br><span class="line">  ipNum</span><br><span class="line">&#125;).toDF(<span class="string">"ip_num"</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建两张视图</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ruleDataFrame.createTempView(<span class="string">"v_rules"</span>)</span><br><span class="line">ipDataFrame.createTempView(<span class="string">"v_ips"</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>执行SQL</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> r = spark.sql(</span><br><span class="line"><span class="string">"SELECT province, count(*) counts </span></span><br><span class="line"><span class="string">FROM v_ips JOIN v_rules </span></span><br><span class="line"><span class="string">ON (ip_num &gt;= snum AND ip_num &lt;= enum)         </span></span><br><span class="line"><span class="string">GROUP BY province ORDER BY counts DESC"</span>        </span><br><span class="line">).show()										<span class="comment">//两表字段非等值内连接</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>关闭数据流</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark.stop</span><br></pre></td></tr></table></figure>

<h4 id="高级版本：缓存广播小表-UDF"><a href="#高级版本：缓存广播小表-UDF" class="headerlink" title="高级版本：缓存广播小表,UDF"></a>高级版本：缓存广播小表,UDF</h4><ol>
<li><p>创建sparkSession</p>
</li>
<li><p>整理IP规则为Array[(Long, Long, String)]，不再创建表了</p>
</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"><span class="keyword">val</span> rulesLines:<span class="type">Dataset</span>[<span class="type">String</span>] = spark.read.textFile(args(<span class="number">0</span>))</span><br><span class="line"><span class="comment">//整理ip规则数据()</span></span><br><span class="line"><span class="keyword">val</span> rluesDataset = rulesLines.map(line =&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">    (startNum, endNum, province)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>收集ip规则到Driver端，并且广播</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rulesInDriver: <span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)] = rluesDataset.collect() <span class="comment">//已缓存内存</span></span><br><span class="line"><span class="comment">//广播(必须使用sparkcontext)</span></span><br><span class="line"><span class="comment">//将广播变量的引用返回到Driver端</span></span><br><span class="line"><span class="keyword">val</span> broadcastRef: <span class="type">Broadcast</span>[<span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)]] = spark.sparkContext.broadcast(rulesInDriver)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>读IP记录创建dataFrame和视图</li>
<li>定义一个自定义函数（UDF），并注册</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数的功能是（输入一个IP地址对应的十进制，返回一个省份名称）</span></span><br><span class="line">spark.udf.register(<span class="string">"ip2Province"</span>, (ipNum: <span class="type">Long</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//查找ip规则（事先已经广播了，已经在Executor中了）</span></span><br><span class="line">  <span class="comment">//函数的逻辑是在Executor中执行的，怎样获取ip规则的对应的数据呢？</span></span><br><span class="line">  <span class="comment">//使用广播变量的引用，就可以获得</span></span><br><span class="line">  <span class="keyword">val</span> ipRulesInExecutor: <span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)] = broadcastRef.value</span><br><span class="line">  <span class="comment">//根据IP地址对应的十进制查找省份名称</span></span><br><span class="line">  <span class="keyword">val</span> index = <span class="type">MyUtils</span>.binarySearch(ipRulesInExecutor, ipNum)</span><br><span class="line">  <span class="keyword">var</span> province = <span class="string">"未知"</span></span><br><span class="line">  <span class="keyword">if</span>(index != <span class="number">-1</span>) &#123;</span><br><span class="line">    province = ipRulesInExecutor(index)._3</span><br><span class="line">  &#125;</span><br><span class="line">  province</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>6.SQL里调用自定义函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spark.sql(</span><br><span class="line">    <span class="string">"SELECT ip2Province(ip_num) province, COUNT(*) counts </span></span><br><span class="line"><span class="string">	FROM v_log </span></span><br><span class="line"><span class="string">	GROUP BY province </span></span><br><span class="line"><span class="string">	ORDER BY counts DESC"</span>).show()</span><br></pre></td></tr></table></figure>

<h3 id="最受欢迎老师TOPN"><a href="#最受欢迎老师TOPN" class="headerlink" title="最受欢迎老师TOPN"></a>最受欢迎老师TOPN</h3><h4 id="hive窗口分析函数"><a href="#hive窗口分析函数" class="headerlink" title="hive窗口分析函数"></a>hive窗口分析函数</h4><ul>
<li><p>row_number() over(partition by subject order by counts desc)    增加行号</p>
</li>
<li><p>rank() over(order by counts desc)       增加序列号（1，2，2，4…）</p>
</li>
<li><p>dense_rank() over(order by counts desc)         增加序列号（1，2，2，3….）</p>
</li>
</ul>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol>
<li>获取sparkSessioni</li>
<li>创建dataFrame   (subject, teacher).toDF(“subject”, “teacher”)</li>
<li>创建视图.createTempView(“v_sub_teacher”)</li>
<li><strong>SQL创建DataFrame</strong>（根据v_sub_teacher表创建多出counts列的新表）</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SQL创建新的DataFrame，该学科下的老师的访问次数</span></span><br><span class="line"><span class="keyword">val</span> temp1: <span class="type">DataFrame</span> = spark.sql(</span><br><span class="line"><span class="string">"SELECT subject, teacher, count(*) counts</span></span><br><span class="line"><span class="string">FROM v_sub_teacher </span></span><br><span class="line"><span class="string">GROUP BY subject, teacher"</span>)</span><br><span class="line"><span class="comment">//创建新视图</span></span><br><span class="line">temp1.createTempView(<span class="string">"v_temp_sub_teacher_counts"</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>对新视图执行SQL</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scala用法：字符串前加s，""内直接用$取参数值</span></span><br><span class="line"><span class="keyword">val</span> temp2 = spark.sql(s</span><br><span class="line"><span class="string">"SELECT *, row_number() over(order by counts desc) g_rk </span></span><br><span class="line"><span class="string">FROM </span></span><br><span class="line"><span class="string">(SELECT subject, teacher, counts, </span></span><br><span class="line"><span class="string">row_number() over(partition by subject order by counts desc) sub_rk</span></span><br><span class="line"><span class="string">FROM v_temp_sub_teacher_counts) temp2 </span></span><br><span class="line"><span class="string">WHERE sub_rk &lt;= $topN"</span>)  <span class="comment">//取出前topN的数据</span></span><br></pre></td></tr></table></figure>

<h3 id="读存多种数据源"><a href="#读存多种数据源" class="headerlink" title="读存多种数据源"></a>读存多种数据源</h3><h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h4><p><strong>读取数据</strong></p>
<ol>
<li>定义Property对象保存连接信息</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> props = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">props.put(<span class="string">"user"</span>,<span class="string">"root"</span>)</span><br><span class="line">props.put(<span class="string">"password"</span>,<span class="string">"root"</span>)</span><br><span class="line">props.put(<span class="string">"driver"</span>,<span class="string">"com.mysql.jdbc.Driver"</span>) <span class="comment">//导入mysql-connector依赖</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用访问jdbc依赖</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> data:<span class="type">DataFrame</span> = spark.read.jdbc(<span class="string">"jdbc:mysql://localhost:3306/fe"</span>,<span class="string">"job"</span>,props)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>打印表信息</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data.printSchema() <span class="comment">//表头信息</span></span><br><span class="line">data.show() <span class="comment">//表信息</span></span><br></pre></td></tr></table></figure>

<p><strong>写入数据</strong></p>
<p><strong>spark.write.mode(“xx”)类型：</strong>Append、ErrorIfExists、Ignore、OverWrite</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> props = <span class="keyword">new</span> <span class="type">Properties</span>() <span class="comment">//写入数据不用jdbcDriver</span></span><br><span class="line">props.put(<span class="string">"user"</span>,<span class="string">"root"</span>)</span><br><span class="line">props.put(<span class="string">"password"</span>,<span class="string">"root"</span>)</span><br><span class="line">reslut.write.mode(<span class="string">"ignore"</span>).jdbc(</span><br><span class="line">    <span class="string">"jdbc:mysql://localhost:3306/bigdata"</span>, <span class="string">"logs1"</span>, props)</span><br></pre></td></tr></table></figure>

<p><strong>备注</strong>：写入text注意</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DataFrame保存成text时(只能保存一列String类型的数据)!!!!</span></span><br><span class="line">reslut.write.text(<span class="string">"/Users/zx/Desktop/text"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p><strong>读取数据</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jsons: <span class="type">DataFrame</span> = spark.read.json(<span class="string">"/Users/zx/Desktop/json"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>写入数据</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reslut.write.json(<span class="string">"/Users/zx/Desktop/json"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h4><p><strong>读取数据</strong></p>
<p>读取出的数据scehma信息为_c1,_c2…_cn  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> csv: <span class="type">DataFrame</span> = spark.read.csv(<span class="string">"/Users/zx/Desktop/csv"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>存入数据</strong></p>
<p>存入数据没有表头信息</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reslut.write.csv(<span class="string">"/Users/zx/Desktop/csv"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Parquet"><a href="#Parquet" class="headerlink" title="Parquet"></a>Parquet</h4><p>Parquet：面向分析型业务的列式存储格式、spark可以只读取其中某几列</p>
<p><strong>读取数据</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> parquetLine: <span class="type">DataFrame</span> = spark.read.parquet(<span class="string">"/Users/zx/Desktop/parquet"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>写入数据</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reslut.write.parquet(<span class="string">"hdfs://node-4:9000/parquet"</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sparkSQL整合hive"><a href="#sparkSQL整合hive" class="headerlink" title="sparkSQL整合hive"></a>sparkSQL整合hive</h3><p>跟hive没太的关系，就是使用了hive的标准（HQL， 元数据库、UDF、序列化、反序列化机制</p>
<p>真正要计算的数据是保存在HDFS中，mysql这个元数据库，保存的是hive表的描述信息，描述了有哪些database、table、以及表有多少列，每一列是什么类型，还要描述表的数据保存在hdfs的什么位置</p>
<p><strong>hive的元数据库的功能：</strong><br>    建立了一种映射关系，执行HQL时，先到MySQL元数据库中查找描述信息，然后根据描述信息生成任务，然后将任务下发到spark集群中执行</p>
<p><strong>pom中导入spark-hive依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-hive_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方式一：spark-sql-shell-配置启动"><a href="#方式一：spark-sql-shell-配置启动" class="headerlink" title="方式一：spark-sql shell 配置启动"></a>方式一：spark-sql shell 配置启动</h4><ol>
<li>安装MySQL（hive的元数据库）并创建一个普通用户，并且授权</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. CREATE USER &apos;xiaoniu&apos;@&apos;%&apos; IDENTIFIED BY &apos;123568&apos;; </span><br><span class="line">2. GRANT ALL PRIVILEGES ON hivedb.* TO &apos;xiaoniu&apos;@&apos;%&apos; IDENTIFIED BY &apos;123568&apos; </span><br><span class="line">WITH GRANT OPTION;</span><br><span class="line">3. FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在spark的conf目录下添加一个hive-site.xml（创建一个hive的配置文件）</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://node-6:3306/hivedb?createDatabaseIfNotExist=true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>bigdata<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>123568<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>上传一个mysql连接驱动（sparkSubmit也要连接MySQL，获取元数据信息）</p>
<p>启动spark-sql shell 命令：（如果mysql驱动在spark/lib下就不用跟driver-class-path）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./spark-sql --master spark://node-4:7077,node-5:7077 --driver-class-path /home/xiaoniu/mysql-connector-java-5.1.7-bin.jar</span><br></pre></td></tr></table></figure>

<p>spark-sql 执行 SQL文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>spark sql 整合hive，将hive的sql写在一个文件中执行（用-f这个参数）</span><br><span class="line">spark-sql --master spark://node-4:7077,node-5:7077 -f hive-sqls.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>sparkSQL会在mysql上创建一个database(hivedb保存元数据信息)</p>
<p><strong>注意！：</strong><u>需要手动改一下</u>DBS表中的DB_LOCATION_UIR(由本地地址file:/)改成hdfs的地址(hdfs://master:9000/xx)</p>
<p><strong>补充</strong>：因为在建表和导入本地数据时虽然可以成功，但spark-sql shell在执行查询等语句时是多台机器在本地查找数据计算，只有本地的机器有数据，其他机器找不到数据从而出错。</p>
</li>
<li><p>要在/etc/profile中配置一个环节变量(让sparkSQL知道hdfs在哪里，其实就是namenode在哪里)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exprot HADOOP_CONF_DIR=$HADOOP_HOME #指定HADOOP配置文件路径</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动SparkSQL的命令行</p>
</li>
</ol>
<h4 id="方式二：IDE中执行"><a href="#方式二：IDE中执行" class="headerlink" title="方式二：IDE中执行"></a>方式二：IDE中执行</h4><ol>
<li>开启spark对hive的支持</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SparkSession</span>.builder().enableHiveSupport()....</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在resource文件夹下添加hive-site.xml<strong>（非高可用）</strong></p>
<p>在本地运行需要元数据库配置文件信息，如果在集群运行就不需要</p>
<p><strong>备注</strong>：如果配置了高可用hdfs（两个namenode，DBS表中的DB_LOCATION_UIR的hdfs路径例如配置为hdfs://ns/xxx，提交运行时找不到hdfs://ns地址，如果是hdfs://master:9000就可以），则还需要添加core-site.xml、hdfs-site.xml</p>
</li>
<li><p>实行sparkSQL（执行HIVE）</p>
</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result: <span class="type">DataFrame</span> = spark.sql(<span class="string">"SELECT * FROM t_boy ORDER BY fv DESC"</span>)</span><br><span class="line"><span class="keyword">val</span> sql: <span class="type">DataFrame</span> = spark.sql(<span class="string">"CREATE TABLE niu (id bigint, name string)"</span>)</span><br><span class="line">result.show()</span><br><span class="line">sql.show</span><br></pre></td></tr></table></figure>

<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><ul>
<li>非高可用：</li>
</ul>
<p>core-site.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>hdfs-site.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/hdpdata/name/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/hdpdata/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>slave1:50090<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>高可用：</p>
<p>见文件：<a href="sparkSQL学习总结/conf/core-site.xml">core-site.xml</a>、<a href="sparkSQL学习总结/conf/hdfs-site.xml">hdfs-site.xml</a></p>
</li>
</ul>
<h2 id="spark1-x"><a href="#spark1-x" class="headerlink" title="spark1.x"></a>spark1.x</h2><h3 id="创建方式一"><a href="#创建方式一" class="headerlink" title="创建方式一"></a>创建方式一</h3><p>1.创建SparkContext</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提交的这个程序可以连接到Spark集群中</span></span><br><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"SQLDemo1"</span>).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line"><span class="comment">//创建SparkSQL的连接（程序执行的入口）</span></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br></pre></td></tr></table></figure>

<p>2.创建SQLContext</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sparkContext不能创建特殊的RDD（DataFrame）</span></span><br><span class="line"><span class="comment">//将SparkContext包装进而增强</span></span><br><span class="line"><span class="keyword">val</span> sqlContext = <span class="keyword">new</span> <span class="type">SQLContext</span>(sc)</span><br></pre></td></tr></table></figure>

<p>3.创建一个类（建议case class不用new和序列化），并定义类的成员变量</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span>(<span class="params">id: <span class="type">Long</span>, name: <span class="type">String</span>, age: <span class="type">Int</span>, fv: <span class="type">Double</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>4.创建RDD,将数据进行整理成class对象（关联class，将非结构化数据转换成结构化数据）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建特殊的RDD（DataFrame），就是有schema信息的RDD</span></span><br><span class="line"><span class="comment">//先有一个普通的RDD，然后在关联上schema，进而转成DataFrame</span></span><br><span class="line"><span class="keyword">val</span> lines = sc.textFile(<span class="string">"hdfs://node-4:9000/person"</span>)</span><br><span class="line"><span class="comment">//将数据进行整理</span></span><br><span class="line"><span class="keyword">val</span> boyRDD: <span class="type">RDD</span>[<span class="type">Boy</span>] = lines.map(line =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> fields = line.split(<span class="string">","</span>)</span><br><span class="line">    <span class="keyword">val</span> id = fields(<span class="number">0</span>).toLong</span><br><span class="line">	...</span><br><span class="line">    <span class="type">Boy</span>(id, name, age, fv)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//该RDD装的是Boy类型的数据，有了shcma信息，但是还是一个RDD</span></span><br></pre></td></tr></table></figure>

<p>6.将RDD转换成DataFrame（导入隐式转换），显式调用toDF方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将RDD转换成DataFrame</span></span><br><span class="line"><span class="comment">//导入隐式转换</span></span><br><span class="line"><span class="keyword">import</span> sqlContext.implicits._</span><br><span class="line"><span class="keyword">val</span> bdf: <span class="type">DataFrame</span> = boyRDD.toDF</span><br><span class="line"><span class="comment">//变成DF后就可以使用两种API进行编程了</span></span><br></pre></td></tr></table></figure>

<p>7.将DataFrame注册成临时表（SQL方法）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把DataFrame先注册临时表</span></span><br><span class="line">bdf.registerTempTable(<span class="string">"t_boy"</span>)</span><br></pre></td></tr></table></figure>

<p>8.书写SQL（Transformation）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//书写SQL（SQL方法应其实是Transformation）</span></span><br><span class="line"><span class="keyword">val</span> result: <span class="type">DataFrame</span> = sqlContext.sql(<span class="string">"SELECT * FROM t_boy ORDER BY fv desc, age asc"</span>)</span><br></pre></td></tr></table></figure>

<p>9.执行Action</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result.show()</span><br><span class="line">sc.stop()</span><br></pre></td></tr></table></figure>

<h3 id="创建方式二"><a href="#创建方式二" class="headerlink" title="创建方式二"></a>创建方式二</h3><p>1.创建SparkContext<br>2.创建SQLContext<br>3.创建RDD，将数据整理成Row对象</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rowRDD: <span class="type">RDD</span>[<span class="type">Row</span>] = lines.map(line =&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="type">Row</span>(id, name, age, fv)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>4.创建StructType（schema）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结果类型，其实就是表头，用于描述DataFrame</span></span><br><span class="line"><span class="keyword">val</span> sch: <span class="type">StructType</span> = <span class="type">StructType</span>(<span class="type">List</span>(</span><br><span class="line">    <span class="type">StructField</span>(<span class="string">"id"</span>, <span class="type">LongType</span>, <span class="literal">true</span>),</span><br><span class="line">    <span class="type">StructField</span>(<span class="string">"name"</span>, <span class="type">StringType</span>, <span class="literal">true</span>),</span><br><span class="line">    <span class="type">StructField</span>(<span class="string">"age"</span>, <span class="type">IntegerType</span>, <span class="literal">true</span>),</span><br><span class="line">    <span class="type">StructField</span>(<span class="string">"fv"</span>, <span class="type">DoubleType</span>, <span class="literal">true</span>)</span><br><span class="line">))</span><br></pre></td></tr></table></figure>

<p>5.通过rowRDD和schema创建DataFrame （使用sqlContext方法，不用导入隐式转换）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将RowRDD关联schem</span></span><br><span class="line"><span class="keyword">val</span> bdf: <span class="type">DataFrame</span> = sqlContext.createDataFrame(rowRDD, sch)</span><br></pre></td></tr></table></figure>

<p>6.使用DSL风格操作数据（dataFrameAPI操作数据）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用SQL的方式，就不用注册临时表了</span></span><br><span class="line"><span class="keyword">val</span> df1: <span class="type">DataFrame</span> = bdf.select(<span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"fv"</span>)</span><br><span class="line"><span class="keyword">import</span> sqlContext.implicits._</span><br><span class="line"><span class="keyword">val</span> df2: <span class="type">DataFrame</span> = df1.orderBy($<span class="string">"fv"</span> desc, $<span class="string">"age"</span> asc)</span><br></pre></td></tr></table></figure>

<p>//6.将DataFrame注册成临时表（SQL方式）<br>//7.书写SQL（Transformation）<br>8.执行Action</p>
<h1 id="导入隐式转换的地方："><a href="#导入隐式转换的地方：" class="headerlink" title="导入隐式转换的地方："></a>导入隐式转换的地方：</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlContext.implicits._</span><br><span class="line"><span class="keyword">val</span> bdf: <span class="type">DataFrame</span> = boyRDD.toDF</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sparkSession.implicits._</span><br><span class="line"><span class="keyword">val</span> df2: <span class="type">Dataset</span>[<span class="type">Row</span>] = df.where($<span class="string">"fv"</span> &gt; <span class="number">98</span>).orderBy($<span class="string">"fv"</span> desc, $<span class="string">"age"</span> asc)</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"><span class="keyword">val</span> lines: <span class="type">Dataset</span>[<span class="type">String</span>] = spark.createDataset(<span class="type">List</span>(<span class="string">"1,laozhoa,china"</span>, <span class="string">"2,laoduan,usa"</span>, <span class="string">"3,laoyang,jp"</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> range: <span class="type">Dataset</span>[<span class="type">Long</span>] = spark.range(<span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"><span class="keyword">val</span> result = range.groupBy().agg(geomean($<span class="string">"id"</span>).as(<span class="string">"geomean"</span>)) <span class="comment">//这里可以不用掉groupBy</span></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spark.implicits._ <span class="comment">//dataSet调用map方法用到了隐式转换</span></span><br><span class="line"><span class="keyword">val</span> rulesLines:<span class="type">Dataset</span>[<span class="type">String</span>] = spark.read.textFile(args(<span class="number">0</span>))</span><br><span class="line"><span class="comment">//整理ip规则数据()</span></span><br><span class="line"><span class="keyword">val</span> ruleDataFrame: <span class="type">DataFrame</span> = rulesLines.map(line =&gt; &#123;...&#125;)</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/24/sparkRDD学习总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cilibili">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/sparkRDD学习总结/" itemprop="url">SparkRDD学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-24T11:07:20+08:00">
                2019-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spark/" itemprop="url" rel="index">
                    <span itemprop="name">spark</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SparkRDD"><a href="#SparkRDD" class="headerlink" title="SparkRDD"></a>SparkRDD</h1><h2 id="day3-最受欢迎老师"><a href="#day3-最受欢迎老师" class="headerlink" title="day3 最受欢迎老师"></a>day3 最受欢迎老师</h2><p>map方法可以返回元组类型</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sbjectTeacherAndOne: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = lines.map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> index = line.lastIndexOf(<span class="string">"/"</span>)</span><br><span class="line">      <span class="keyword">val</span> teacher = line.substring(index + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">val</span> httpHost = line.substring(<span class="number">0</span>, index)</span><br><span class="line">      <span class="keyword">val</span> subject = <span class="keyword">new</span> <span class="type">URL</span>(httpHost).getHost.split(<span class="string">"[.]"</span>)(<span class="number">0</span>) <span class="comment">//“.”是特殊字符，要用[]</span></span><br><span class="line">      ((subject, teacher), <span class="number">1</span>) <span class="comment">//学科和老师联合当作key</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>下划线的操作</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = sbjectAndteacher.map((_, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">val</span> reduced: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = sbjectTeacherAndOne.reduceByKey(_+_)</span><br></pre></td></tr></table></figure>

<p><strong>排序操作的比较</strong>：</p>
<ol>
<li>变为scala集合进行排序：</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.toList方法就是将RDD中的数据以scala集合存放进内存，用scala方法进行排序</span></span><br><span class="line"><span class="keyword">val</span> sorted = grouped.mapValues(_.toList.sortBy(_._2).reverse.take(topN))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>过滤出不同学科进行操作，调用RDD的sortBy方法</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> subjects = <span class="type">Array</span>(<span class="string">"bigdata"</span>, <span class="string">"javaee"</span>, <span class="string">"php"</span>)</span><br><span class="line"><span class="keyword">for</span> (sb &lt;- subjects) &#123;</span><br><span class="line">      <span class="comment">//该RDD中对应的数据仅有一个学科的数据（因为过滤过了）</span></span><br><span class="line">      <span class="keyword">val</span> filtered: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = reduced.filter(_._1._1 == sb)</span><br><span class="line">      <span class="comment">//现在调用的是RDD的sortBy方法，(take是一个action，会触发任务提交)</span></span><br><span class="line">      <span class="keyword">val</span> favTeacher = filtered.sortBy(_._2, <span class="literal">false</span>).take(topN)</span><br><span class="line">      <span class="comment">//打印 ==必须要加上toBuffer==</span></span><br><span class="line">      println(favTeacher.toBuffer)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>自定义分区</strong>：将相同学科的数据利用自定义分区规则，到同一个分区</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//聚合，将学科和老师联合当做key</span></span><br><span class="line"><span class="keyword">val</span> reduced: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = sbjectTeacherAndOne.reduceByKey(_+_)</span><br><span class="line"><span class="comment">//计算有多少学科</span></span><br><span class="line"><span class="keyword">val</span> subjects: <span class="type">Array</span>[<span class="type">String</span>] = reduced.map(_._1._1).distinct().collect()</span><br><span class="line"><span class="comment">//自定义一个分区器，并且按照指定的分区器进行分区</span></span><br><span class="line"><span class="keyword">val</span> sbPatitioner = <span class="keyword">new</span> <span class="type">SubjectParitioner</span>(subjects);</span><br><span class="line"><span class="comment">//partitionBy按照指定的分区规则进行分区</span></span><br><span class="line"><span class="comment">//调用partitionBy时RDD的Key是(String, String)，因为类型为reduced: RDD[((String, String), Int)]</span></span><br><span class="line"><span class="keyword">val</span> partitioned: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = reduced.partitionBy(sbPatitioner)</span><br><span class="line"><span class="comment">//如果一次拿出一个分区(可以操作一个分区中的数据了)</span></span><br><span class="line"><span class="keyword">val</span> sorted: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = partitioned.mapPartitions(it =&gt; &#123;</span><br><span class="line">	<span class="comment">//将迭代器（里的数据）转换成list，然后排序，在转换成迭代器返回</span></span><br><span class="line">	it.toList.sortBy(_._2).reverse.take(topN).iterator</span><br><span class="line">	&#125;)</span><br><span class="line"><span class="keyword">val</span> r: <span class="type">Array</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = sorted.collect()</span><br><span class="line">println(r.toBuffer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">自定义分区器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubjectParitioner</span>(<span class="params">sbs: <span class="type">Array</span>[<span class="type">String</span>]</span>) <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">  <span class="comment">//相当于主构造器（new的时候回执行一次）</span></span><br><span class="line">  <span class="comment">//用于存放规则的一个map</span></span><br><span class="line">  <span class="keyword">val</span> rules = <span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Int</span>]()</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(sb &lt;- sbs) &#123;</span><br><span class="line">    <span class="comment">//rules(sb) = i</span></span><br><span class="line">    rules.put(sb, i)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回分区的数量（下一个RDD有多少分区）</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = sbs.length</span><br><span class="line">  <span class="comment">//根据传入的key计算分区标号</span></span><br><span class="line">  <span class="comment">//key是一个元组（String， String）</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="comment">//获取学科名称  强转为RDD的[(String, String)]类型</span></span><br><span class="line">    <span class="keyword">val</span> subject = key.asInstanceOf[(<span class="type">String</span>, <span class="type">String</span>)]._1</span><br><span class="line">    <span class="comment">//根据规则计算分区编号</span></span><br><span class="line">    rules(subject)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>对自定义分区器改进：shuffle次数减少</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> reduced: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = s..e.reduceByKey(sbPatitioner, _+_)</span><br><span class="line"><span class="comment">//直接在reduceByKey里传入一个分区器，整合了上面的reduceBykey和partitionBy两次shuffle</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="day4-求ip归属地"><a href="#day4-求ip归属地" class="headerlink" title="day4 求ip归属地"></a>day4 求ip归属地</h2><ul>
<li><h4 id="读取文件内容方法：（以内存方式存数据）"><a href="#读取文件内容方法：（以内存方式存数据）" class="headerlink" title="读取文件内容方法：（以内存方式存数据）"></a>读取文件内容方法：（以内存方式存数据）</h4></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readRules</span></span>(path: <span class="type">String</span>): <span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)] = &#123;</span><br><span class="line">    <span class="comment">//读取ip规则</span></span><br><span class="line">    <span class="keyword">val</span> bf: <span class="type">BufferedSource</span> = <span class="type">Source</span>.fromFile(path)</span><br><span class="line">    <span class="keyword">val</span> lines: <span class="type">Iterator</span>[<span class="type">String</span>] = bf.getLines()</span><br><span class="line">    <span class="comment">//对ip规则进行整理，并放入到内存</span></span><br><span class="line">    <span class="keyword">val</span> rules: <span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)] = lines.map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> fileds = line.split(<span class="string">"[|]"</span>)</span><br><span class="line">      <span class="keyword">val</span> startNum = fileds(<span class="number">2</span>).toLong</span><br><span class="line">      <span class="keyword">val</span> endNum = fileds(<span class="number">3</span>).toLong</span><br><span class="line">      <span class="keyword">val</span> province = fileds(<span class="number">6</span>)</span><br><span class="line">      (startNum, endNum, province)</span><br><span class="line">    &#125;).toArray</span><br><span class="line">    rules <span class="comment">//返回一个Array，调用这个方法时Array数据存放在内存里</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>读取文件内容方法：（<strong>以RDD形式读取数据</strong>）</p>
<p>分布式读取处理数据，用collect方法把所有数据收集起来</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取到HDFS中的ip规则</span></span><br><span class="line"><span class="keyword">val</span> rulesLines:<span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(args(<span class="number">0</span>))</span><br><span class="line"><span class="comment">//整理ip规则数据</span></span><br><span class="line"><span class="keyword">val</span> ipRulesRDD: <span class="type">RDD</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)] = rulesLines.map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> fields = line.split(<span class="string">"[|]"</span>)</span><br><span class="line">      <span class="keyword">val</span> startNum = fields(<span class="number">2</span>).toLong</span><br><span class="line">      <span class="keyword">val</span> endNum = fields(<span class="number">3</span>).toLong</span><br><span class="line">      <span class="keyword">val</span> province = fields(<span class="number">6</span>)</span><br><span class="line">      (startNum, endNum, province)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">//将分散在多个Executor中的部分IP规则收集到Driver端</span></span><br><span class="line"><span class="keyword">val</span> rulesInDriver: <span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)] = ipRulesRDD.collect()</span><br><span class="line"></span><br><span class="line"><span class="comment">//将Driver端的数据广播到Executor</span></span><br><span class="line"><span class="comment">//广播变量的引用（还在Driver端）</span></span><br><span class="line"><span class="keyword">val</span> broadcastRef: <span class="type">Broadcast</span>[<span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)]] = sc.broadcast(rulesInDriver)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  处理文件逻辑：</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Driver端获取到全部的IP规则数据（全部的IP规则数据在某一台机器上，跟Driver在同一台机器上）</span></span><br><span class="line"><span class="comment">//全部的IP规则在Driver端了（在Driver端的内存中了）</span></span><br><span class="line"><span class="keyword">val</span> rules: <span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)] = <span class="type">MyUtils</span>.readRules(args(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//将Drive端的数据广播到Executor中</span></span><br><span class="line"><span class="comment">//调用sc上的广播方法</span></span><br><span class="line"><span class="comment">//广播变量的引用（还在Driver端）</span></span><br><span class="line"><span class="keyword">val</span> broadcastRef: <span class="type">Broadcast</span>[<span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)]] = sc.broadcast(rules)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建RDD，读取访问日志</span></span><br><span class="line"><span class="keyword">val</span> accessLines: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(args(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数是在哪一端定义的？（Driver）</span></span><br><span class="line"><span class="keyword">val</span> func = (line: <span class="type">String</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> fields = line.split(<span class="string">"[|]"</span>)</span><br><span class="line">    <span class="keyword">val</span> ip = fields(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//将ip转换成十进制</span></span><br><span class="line">    <span class="keyword">val</span> ipNum = <span class="type">MyUtils</span>.ip2Long(ip)</span><br><span class="line">    <span class="comment">//进行二分法查找，通过Driver端的引用或取到Executor中的广播变量</span></span><br><span class="line">    <span class="comment">//（该函数中的代码是在Executor中别调用执行的，通过广播变量的引用，就可以拿到当前Executor中的广播的规则了），Task是在Driver端生成的，广播变量的引用是伴随着Task被发送到Executor中的</span></span><br><span class="line">    <span class="keyword">val</span> rulesInExecutor: <span class="type">Array</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)] = broadcastRef.value</span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="keyword">var</span> province = <span class="string">"未知"</span></span><br><span class="line">    <span class="keyword">val</span> index = <span class="type">MyUtils</span>.binarySearch(rulesInExecutor, ipNum)</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">			province = rulesInExecutor(index)._3</span><br><span class="line">        &#125;</span><br><span class="line">			(province, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//整理数据</span></span><br><span class="line"><span class="keyword">val</span> proviceAndOne: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = accessLines.map(func)</span><br><span class="line"><span class="keyword">val</span> reduced: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = proviceAndOne.reduceByKey(_+_)</span><br><span class="line"><span class="comment">//将结果打印</span></span><br><span class="line"><span class="keyword">val</span> r = reduced.collect()</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>连接JDBC，将数据写入数据库：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次拿出一个分区(一个分区用一个连接，可以将一个分区中的多条数据写完在释放jdbc连接，这样更节省资源) 这是一个action</span></span><br><span class="line">reduced.foreachPartition(it =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> conn: <span class="type">Connection</span> = <span class="type">DriverManager</span>.getConnection(<span class="string">"jdbc:mysql://localhost:3306/bigdata?characterEncoding=UTF-8"</span>, <span class="string">"root"</span>, <span class="string">"123568"</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//将数据通过Connection写入到数据库</span></span><br><span class="line">  <span class="keyword">val</span> pstm: <span class="type">PreparedStatement</span> = conn.prepareStatement(<span class="string">"INSERT INTO access_log VALUES (?, ?)"</span>)</span><br><span class="line">  <span class="comment">//将一个分区中的每一条数据拿出来</span></span><br><span class="line">  it.foreach(tp =&gt; &#123;</span><br><span class="line">    pstm.setString(<span class="number">1</span>, tp._1)</span><br><span class="line">    pstm.setInt(<span class="number">2</span>, tp._2)</span><br><span class="line">    pstm.executeUpdate()</span><br><span class="line">  &#125;)</span><br><span class="line">  pstm.close()</span><br><span class="line">  conn.close()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>改进：将匿名内部类写成方法传入参数：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data2MySQL</span></span>(it: <span class="type">Iterator</span>[(<span class="type">String</span>, <span class="type">Int</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">//一个迭代器代表一个分区，分区中有多条数据</span></span><br><span class="line">  <span class="comment">//先获得一个JDBC连接</span></span><br><span class="line">  <span class="keyword">val</span> conn: <span class="type">Connection</span> = <span class="type">DriverManager</span>.getConnection(<span class="string">"jdbc:mysql://..."</span>)</span><br><span class="line">  <span class="comment">//将数据通过Connection写入到数据库</span></span><br><span class="line">  <span class="keyword">val</span> pstm: <span class="type">PreparedStatement</span> = conn.prepareStatement(<span class="string">"INSERT INTO .. VALUES (?, ?)"</span>)</span><br><span class="line">  <span class="comment">//将分区中的数据一条一条写入到MySQL中</span></span><br><span class="line">  it.foreach(tp =&gt; &#123;</span><br><span class="line">    pstm.setString(<span class="number">1</span>, tp._1)</span><br><span class="line">    pstm.setInt(<span class="number">2</span>, tp._2)</span><br><span class="line">    pstm.executeUpdate()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//将分区中的数据全部写完之后，在关闭连接</span></span><br><span class="line">  <span class="keyword">if</span>(pstm != <span class="literal">null</span>) &#123;</span><br><span class="line">    pstm.close()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">    conn.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法调用：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reduced.foreachPartition(it =&gt; <span class="type">MyUtils</span>.data2MySQL(it))<span class="comment">//方法一</span></span><br><span class="line">reduced.foreachPartition(<span class="type">MyUtils</span>.data2MySQL() _)<span class="comment">//方法二 下划线将方法转为函数</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><h4 id="JdbcRDD"><a href="#JdbcRDD" class="headerlink" title="JdbcRDD"></a>JdbcRDD</h4></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">JdbcRddDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> getConn = () =&gt; &#123;</span><br><span class="line">    <span class="type">DriverManager</span>.getConnection(<span class="string">"jdbc:mysql://localhost:3306/bigdata?characterEncoding=UTF-8"</span>, <span class="string">"root"</span>, <span class="string">"123568"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"JdbcRddDemo"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">    <span class="comment">//创建RDD，这个RDD会记录以后从MySQL中读数据</span></span><br><span class="line">    <span class="comment">//new 了RDD，里面没有真正要计算的数据，而是告诉这个RDD，以后触发Action时到哪里读取数据</span></span><br><span class="line">    <span class="keyword">val</span> jdbcRDD: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Int</span>)] = <span class="keyword">new</span> <span class="type">JdbcRDD</span>(</span><br><span class="line">      sc, <span class="comment">//sparkContext</span></span><br><span class="line">      getConn,</span><br><span class="line">      <span class="string">"SELECT * FROM logs WHERE id &gt;= ? AND id &lt;= ?"</span>, </span><br><span class="line">      <span class="comment">//注意！：这里必须有等于，不然下一个分区会少包含id 后面的那个数</span></span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      <span class="number">5</span>,</span><br><span class="line">      <span class="number">2</span>, <span class="comment">//分区数量</span></span><br><span class="line">      rs =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> id = rs.getInt(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> name = rs.getString(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">val</span> age = rs.getInt(<span class="number">3</span>)</span><br><span class="line">        (id, name, age)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">//触发Action</span></span><br><span class="line">    <span class="keyword">val</span> r = jdbcRDD.collect()</span><br><span class="line">    println(r.toBuffer)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意！</strong>：这里必须有等于，不然下一个分区会少包含id 后面的那个数</p>
<ul>
<li><h4 id="cache与checkpoint"><a href="#cache与checkpoint" class="headerlink" title="cache与checkpoint"></a>cache与checkpoint</h4><h5 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h5><ul>
<li>cache方法，没有生成新的RDD，也没有触发任务执行，只会标记该RDD分区对应的数据（第一次触发Action时）放入到内存</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cached = reduced.cache()</span><br><span class="line">cached.unpersisted(<span class="literal">true</span>)<span class="comment">//释放cached占用的内存，true表示非阻塞式释放内存</span></span><br></pre></td></tr></table></figure>

<ul>
<li>什么时候进行cache<pre><code>1.要求的计算速度快
  2.集群的资源要足够大
  3.重要：cache的数据会多次的触发Action
  4.先进行过滤，然后将缩小范围的数据在cache到内存</code></pre></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数，放到磁盘</span></span><br><span class="line"><span class="comment">//第二个参数，放到内存</span></span><br><span class="line"><span class="comment">//第三个参数，磁盘中的数据，不是以java对象的方式保存</span></span><br><span class="line"><span class="comment">//第四个参数，内存中的数据，以java对象的方式保存</span></span><br><span class="line"><span class="keyword">val</span> <span class="type">MEMORY_AND_DISK</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h5 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h5><ul>
<li>checkpoint方法，没有生成新的RDD，也是没有触发Action，也是标记以后触发Action时会将数据保存到HDFS中</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.setCheckpointDir(<span class="string">"hdfs://node-4:9000/ck"</span>)</span><br><span class="line">reduced.checkpoint()<span class="comment">//将reduced中的数据保存在checkpoint中，checkpoint改变了RDD的继承关系</span></span><br></pre></td></tr></table></figure>

<ul>
<li>什么时候做checkpoint<pre><code>1.迭代计算，要求保证数据安全
  2.对速度要求不高（跟cache到内存进行对比）
  3.将中间结果保存到hdfs</code></pre></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置checkpoint目录（分布式文件系统的目录hdfs目录）</span></span><br><span class="line"><span class="comment">//经过复杂进行，得到中间结果</span></span><br><span class="line"><span class="comment">//将中间结果checkpoint到指定的hdfs目录</span></span><br><span class="line"><span class="comment">//后续的计算，就可以使用前面ck的数据了</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="day5-自定义排序和切分Stage"><a href="#day5-自定义排序和切分Stage" class="headerlink" title="day5 自定义排序和切分Stage"></a>day5 自定义排序和切分Stage</h2><h3 id="1-自定义排序"><a href="#1-自定义排序" class="headerlink" title="1 自定义排序"></a>1 自定义排序</h3><ol>
<li>在一个类里实现ordered或者ordering接口，将要处理的数据封装成RDD</li>
</ol>
<p>实现ordered接口的类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span>, val fv: <span class="type">Int</span></span>) </span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Ordered</span>[<span class="type">User</span>] <span class="keyword">with</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现序列化，因为在shuffle过程中封装数据的User要序列化，需要在网络传输</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">User</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.fv == that.fv) &#123;</span><br><span class="line">      <span class="keyword">this</span>.age - that.age</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      -(<span class="keyword">this</span>.fv - that.fv)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = <span class="string">s"name: <span class="subst">$name</span>, age: <span class="subst">$age</span>, fv: <span class="subst">$fv</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切分整理数据</span></span><br><span class="line"><span class="keyword">val</span> userRDD: <span class="type">RDD</span>[<span class="type">User</span>] = lines.map(line =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> fields = line.split(<span class="string">" "</span>)</span><br><span class="line">  <span class="keyword">val</span> name = fields(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">val</span> age = fields(<span class="number">1</span>).toInt</span><br><span class="line">  <span class="keyword">val</span> fv = fields(<span class="number">2</span>).toInt</span><br><span class="line">  <span class="comment">//(name, age, fv)</span></span><br><span class="line">  <span class="keyword">new</span> <span class="type">User</span>(name, age, fv)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将RDD里面装的User类型的数据进行排序</span></span><br><span class="line"><span class="keyword">val</span> sorted: <span class="type">RDD</span>[<span class="type">User</span>] = userRDD.sortBy(u =&gt; u) <span class="comment">//传入参数就是u，u就是匹配规则</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在类里实现ordered或者ordering接口（类里只包含需要参与排序的属性），将要处理的数据封装成tupple</li>
</ol>
<p>只含排序参数的类：</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>(<span class="params">val age: <span class="type">Int</span>, val fv: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Ordered</span>[<span class="type">Boy</span>] <span class="keyword">with</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">Boy</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.fv == that.fv) &#123;</span><br><span class="line">      <span class="keyword">this</span>.age - that.age</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      -(<span class="keyword">this</span>.fv - that.fv)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   调用方法：数据整理成tupple，排序逻辑传入排序类的对象</p>
   <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切分整理数据</span></span><br><span class="line"><span class="keyword">val</span> tpRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>, <span class="type">Int</span>)] = lines.map(line =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> fields = line.split(<span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">val</span> name = fields(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> age = fields(<span class="number">1</span>).toInt</span><br><span class="line">    <span class="keyword">val</span> fv = fields(<span class="number">2</span>).toInt</span><br><span class="line">    (name, age, fv)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序(传入了一个排序规则，不会改变数据的格式，只会改变顺序)</span></span><br><span class="line">    <span class="keyword">val</span> sorted: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>, <span class="type">Int</span>)] = tpRDD.sortBy(tp =&gt; <span class="keyword">new</span> <span class="type">Boy</span>(tp._2, tp._3))</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>利用模式匹配类（case class父类实现了Serializable接口）,也不用new 对象，但是对象也是多例的</li>
</ol>
<p>模式匹配类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span>(<span class="params">age: <span class="type">Int</span>, fv: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Ordered</span>[<span class="type">Man</span>] </span>&#123; <span class="comment">//参数都是val类型</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">Man</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.fv == that.fv) &#123;</span><br><span class="line">      <span class="keyword">this</span>.age - that.age</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      -(<span class="keyword">this</span>.fv - that.fv)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方法：不用显示地去new对象，但对象还是多例的</p>
   <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...前面相同</span><br><span class="line"><span class="keyword">val</span> sorted: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>, <span class="type">Int</span>)] = tpRDD.sortBy(tp =&gt; <span class="type">Man</span>(tp._2, tp._3))</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>传入sortBy方法的一个隐式参数</li>
</ol>
<p>有隐式参数的类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SortRules</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">OrderingXiaoRou</span> <span class="keyword">extends</span> <span class="title">Ordering</span>[<span class="type">XianRou</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">XianRou</span>, y: <span class="type">XianRou</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">      <span class="keyword">if</span>(x.fv == y.fv) &#123;</span><br><span class="line">        x.age - y.age</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y.fv - x.fv</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方法：导入隐式参数方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序(传入了一个排序规则，不会改变数据的格式，只会改变顺序)</span></span><br><span class="line"><span class="keyword">import</span> <span class="type">SortRules</span>.<span class="type">OrderingXiaoRou</span></span><br><span class="line"><span class="keyword">val</span> sorted: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>, <span class="type">Int</span>)] = tpRDD.sortBy(tp =&gt; <span class="type">XianRou</span>(tp._2, tp._3))</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">XianRou</span>(<span class="params">age: <span class="type">Int</span>, fv: <span class="type">Int</span></span>)<span class="title">//只定义这个类</span></span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>利用tupple的比较规则：</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...前面相同</span><br><span class="line"><span class="comment">//充分利用元组的比较规则，元组的比较规则：先比第一，相等再比第二个</span></span><br><span class="line"><span class="keyword">val</span> sorted: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>, <span class="type">Int</span>)] = tpRDD.sortBy(tp =&gt; (-tp._3, tp._2))</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>利用tupple的比较规则2</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Ordering[(Int, Int)]最终比较的规则格式</span></span><br><span class="line"><span class="comment">//on[(String, Int, Int)]未比较之前的数据格式</span></span><br><span class="line"><span class="comment">//(t =&gt;(-t._3, t._2))怎样将规则转换成想要比较的格式</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> rules = <span class="type">Ordering</span>[(<span class="type">Int</span>, <span class="type">Int</span>)].on[(<span class="type">String</span>, <span class="type">Int</span>, <span class="type">Int</span>)](t =&gt;(-t._3, t._2))</span><br><span class="line"><span class="keyword">val</span> sorted: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>, <span class="type">Int</span>)] = tpRDD.sortBy(tp =&gt; tp)</span><br><span class="line">备注：有隐式参数的比较规则时会先调用隐式参数比较规则</span><br></pre></td></tr></table></figure>

<h3 id="2-切分Stage"><a href="#2-切分Stage" class="headerlink" title="2 切分Stage"></a>2 切分Stage</h3><ul>
<li>四个步骤</li>
</ul>
<ol>
<li><p>构建DAG（调用RDD上的方法）</p>
</li>
<li><p>DAGScheduler将DAG切分Stage（切分的依据是Shuffle），将Stage中生成的Task以TaskSet的形式给TaskScheduler</p>
</li>
<li><p>TaskScheduler调度Task（根据资源情况将Task调度到相应的Executor中）</p>
</li>
<li><p>Executor接收Task，然后将Task丢入到线程池中执行</p>
</li>
</ol>
<ul>
<li>为什么要切分Stage？<pre><code>一个复杂的业务逻辑（将多台机器上具有相同属性的数据聚合到一台机器上：shuffle）
  如果有shuffle，那么就意味着前面阶段产生的结果后，才能执行下一个阶段，下一个阶段的计算要依赖上一个阶段的数据。
  在同一个Stage中，会有多个算子，可以合并在一起，我们称其为pipeline（流水线：严格按照流程、顺序执行）</code></pre></li>
</ul>
<p><img src="//yoursite.com/2019/07/24/sparkRDD学习总结/sparkRDD%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%5C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="执行过程"></p>
<img src="/2019/07/24/sparkRDD学习总结/执行过程.png">

<h2 id="day6-序列化及多线程问题"><a href="#day6-序列化及多线程问题" class="headerlink" title="day6 序列化及多线程问题"></a>day6 序列化及多线程问题</h2><h3 id="1-序列化问题"><a href="#1-序列化问题" class="headerlink" title="1 序列化问题"></a>1 序列化问题</h3><ul>
<li><p>方法一：在map方法里new 对象，在每个Task里面类加载，每map一条数据就会生成对象</p>
<p>​        缺点：非常浪费资源</p>
</li>
<li><p>方法二：在map方法前先new对象，map操作使用这个对象的引用。但是对象的类需要序列化</p>
<p>​        缺点：在一个Excutor里的每个Task都会反序列化出不同的对象</p>
</li>
<li><p>方法三：将类定义为Object，Excutor在加载类的时候只会加载一次，在一个Excutor里的所有Task都会共用这个”静态类(Object)“里的属性和方法</p>
<p>​        缺点：Object在Driver端生成，通过网络传输到各个Excutor占时间</p>
</li>
<li><p>方法四：只在Map方法里使用Object的属性或者方法。可以不用网络传输对象了，直接在Excutor里加载类</p>
</li>
</ul>
<p>定义的规则类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rules</span> </span>&#123;									------------------------&gt;方法一</span><br><span class="line">  <span class="keyword">val</span> rulesMap = <span class="type">Map</span>(<span class="string">"hadoop"</span> -&gt; <span class="number">2.7</span>, <span class="string">"spark"</span> -&gt; <span class="number">2.2</span>)</span><br><span class="line">  <span class="keyword">val</span> hostname = <span class="type">InetAddress</span>.getLocalHost.getHostName</span><br><span class="line">  println(hostname + <span class="string">"@@@@@@@@@@@@@@@@"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rules</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;				------------------------&gt;方法二</span><br><span class="line">  <span class="keyword">val</span> rulesMap = <span class="type">Map</span>(<span class="string">"hadoop"</span> -&gt; <span class="number">2.7</span>, <span class="string">"spark"</span> -&gt; <span class="number">2.2</span>)</span><br><span class="line">  <span class="keyword">val</span> hostname = <span class="type">InetAddress</span>.getLocalHost.getHostName</span><br><span class="line">  println(hostname + <span class="string">"@@@@@@@@@@@@@@@@"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Rules</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;				------------------------&gt;方法三</span><br><span class="line">  <span class="keyword">val</span> rulesMap = <span class="type">Map</span>(<span class="string">"hadoop"</span> -&gt; <span class="number">2.7</span>, <span class="string">"spark"</span> -&gt; <span class="number">2.2</span>)</span><br><span class="line">  <span class="keyword">val</span> hostname = <span class="type">InetAddress</span>.getLocalHost.getHostName</span><br><span class="line">  println(hostname + <span class="string">"@@@@@@@@@@@@@@@@"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种方式，希望Rules在EXecutor中被初始化（不走网络了，就不必实现序列化接口）</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Rules</span> </span>&#123;									------------------------&gt;方法四</span><br><span class="line">  <span class="keyword">val</span> rulesMap = <span class="type">Map</span>(<span class="string">"hadoop"</span> -&gt; <span class="number">2.7</span>, <span class="string">"spark"</span> -&gt; <span class="number">2.2</span>)</span><br><span class="line">  <span class="keyword">val</span> hostname = <span class="type">InetAddress</span>.getLocalHost.getHostName</span><br><span class="line">  println(hostname + <span class="string">"@@@@@@@@@@@@@@@@"</span>)</span><br><span class="line">  </span><br><span class="line">  备注： 这里pritln方法就相当于静态代码块，在类加载的时候会执行。</span><br><span class="line">  		可以利用这个方法来实现读取共享数据等操作。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SerTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在Driver端被实例化		</span></span><br><span class="line">    <span class="comment">//val rules = new Rules					------------------------&gt;方法二</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化object（在Driver端）</span></span><br><span class="line">    <span class="comment">//var rules = Rules						------------------------&gt;方法三</span></span><br><span class="line">    <span class="comment">//println("@@@@@@@@@@@@" + rules.toString + "@@@@@@@@@@@@")</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"SerTest"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">    <span class="keyword">val</span> lines: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(args(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">val</span> r = lines.map(word =&gt; &#123;</span><br><span class="line">      <span class="comment">//在map的函数中，创建一个rules实例(太浪费资源)</span></span><br><span class="line">      <span class="comment">//val rules = new Rules 				------------------------&gt;方法一</span></span><br><span class="line">      <span class="comment">//函数的执行是在Executor执行的（Task中执行的）</span></span><br><span class="line">      <span class="keyword">val</span> hostname = <span class="type">InetAddress</span>.getLocalHost.getHostName</span><br><span class="line">      <span class="keyword">val</span> threadName = <span class="type">Thread</span>.currentThread().getName</span><br><span class="line">      <span class="comment">//rules的实际是在Executor中使用的</span></span><br><span class="line">      (hostname, threadName, <span class="type">Rules</span>.rulesMap.getOrElse(word, <span class="number">0</span>), <span class="type">Rules</span>.toString)</span><br><span class="line">    &#125;)</span><br><span class="line">      <span class="comment">//在map方法里用到Rules的引用rules			------------------------&gt;方法一~三</span></span><br><span class="line">      <span class="comment">//只在map方法里用到Rules(Object)的属性或方法------------------------&gt;方法四</span></span><br><span class="line">    r.saveAsTextFile(args(<span class="number">1</span>))</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-多线程问题"><a href="#2-多线程问题" class="headerlink" title="2 多线程问题"></a>2 多线程问题</h3><p>以SimpleDateFormat格式化处理日志中时间为例</p>
<p><strong>多线程问题：</strong> 如果object使用了成员变量（且这个成员变量是线程不安全的），那么会出现线程安全问题，因为object是一个单例，多线程(一个Excutor里多个Task)可以同时调用这个方法。</p>
<p>时间处理工具类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FilterUtilsV4</span></span>&#123;</span><br><span class="line">  <span class="comment">//如果object使用了成员变量，那么会出现线程安全问题，因为object是一个单例，多线程(一个Excutor里多个Task)可以同时调用这个方法</span></span><br><span class="line">  <span class="keyword">val</span> dateFormat = <span class="keyword">new</span> <span class="type">SimpleDateFormat</span>(<span class="string">"yyyy年MM月dd日,E,HH:mm:ss"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filterByTime</span></span>(fields: <span class="type">Array</span>[<span class="type">String</span>], startTime: <span class="type">Long</span>, endTime: <span class="type">Long</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> time = fields(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> timeLong = dateFormat.parse(time).getTime</span><br><span class="line">    timeLong &gt;= startTime &amp;&amp; timeLong &lt; endTime</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"GameKPI"</span>).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"><span class="comment">//整理并过滤</span></span><br><span class="line"><span class="keyword">val</span> splited: <span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">String</span>]] = lines.map(line =&gt; line.split(<span class="string">"[|]"</span>))</span><br><span class="line"><span class="keyword">val</span> filtered = splited.filter(fields =&gt; &#123;</span><br><span class="line">    <span class="comment">//如果FilterUtilsV4是一个object，把FilterUtilsV4写在函数内部，它是在Executor中被初始化的</span></span><br><span class="line">    <span class="comment">//FilterUtilsV4是在一个Executor进程中是单例的</span></span><br><span class="line">  <span class="type">FilterUtilsV4</span>.filterByTime(fields, startTime, endTime)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>解决方法一：用线程安全的成员变量，或者加锁</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FastDateFormat是线程安全的，即用线程安全的成员变量</span></span><br><span class="line"><span class="keyword">val</span> dateFormat = <span class="type">FastDateFormat</span>.getInstance(<span class="string">"yyyy年MM月dd日,E,HH:mm:ss"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>解决方法二：将Object类改为Class类，这样每个Task都会反序列化出不同的对象</li>
</ul>
<p>时间处理工具类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterUtilsV3</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> dateFormat = <span class="keyword">new</span> <span class="type">SimpleDateFormat</span>(<span class="string">"yyyy年MM月dd日,E,HH:mm:ss"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filterByTime</span></span>(fields: <span class="type">Array</span>[<span class="type">String</span>], startTime: <span class="type">Long</span>, endTime: <span class="type">Long</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> time = fields(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> timeLong = dateFormat.parse(time).getTime</span><br><span class="line">    timeLong &gt;= startTime &amp;&amp; timeLong &lt; endTime</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...前面的相同</span><br><span class="line"><span class="keyword">val</span> fu = <span class="keyword">new</span> <span class="type">FilterUtilsV3</span> <span class="keyword">with</span> <span class="type">Serializable</span>  <span class="comment">//对象在new出来的时候实现序列化（匿名内部类）</span></span><br><span class="line"><span class="keyword">val</span> filtered = splited.filter(fields =&gt; &#123;</span><br><span class="line">  fu.filterByTime(fields, startTime, endTime) <span class="comment">//在这里用前面new出来的对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="疑惑问题："><a href="#疑惑问题：" class="headerlink" title="疑惑问题："></a>疑惑问题：</h3><p><strong>scala闭包</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/22/git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cilibili">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/git/" itemprop="url">常用Git操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-22T10:07:20+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常用Git操作"><a href="#常用Git操作" class="headerlink" title="常用Git操作"></a>常用Git操作</h1><h2 id="关联本地仓库和远程仓库"><a href="#关联本地仓库和远程仓库" class="headerlink" title="关联本地仓库和远程仓库"></a>关联本地仓库和远程仓库</h2><p>（如果</p>
<p>（若第一次创建仓库，最开始需要生成ssh.pub，把内容在github设置里添加进去）</p>
<p>git init<br>git remote add origin <a href="https://github.com/tugenhua0707/testgit.git" target="_blank" rel="noopener">https://github.com/tugenhua0707/testgit.git</a><br>git pull origin master  –allow-unrelated-histories (如果远程仓库创建了README.md，但本地仓库没有此文件或内容不同时，需要先执行这个命令)<br>git push -u origin master(第一次要用-u 以后不需要)</p>
<p><strong>关联本地分支与远程分支</strong>：</p>
<p>git checkout  –b dev origin/dev创建远程origin的dev分支到本地来<br>git branch –set -upstream dev origin/dev设置本地dev分支与远程origin/dev分支的链接</p>
<h2 id="解决冲突常用"><a href="#解决冲突常用" class="headerlink" title="解决冲突常用"></a>解决冲突常用</h2><p><strong>回退版本</strong></p>
<p>git reset –hard HDEA^^<br>git reset – hard ~100<br>git reset –hard 版本号</p>
<p><strong>工作现场与本地缓存差异</strong></p>
<p>git diff file.txt<br>git checkout –file.txt</p>
<p>git stash list<br>git stash apply/git stash drop/git stash pop</p>
<p><strong>查看提交记录</strong></p>
<p>git log 查看历史commit记录<br>git log –pretty=oneline</p>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>git merge dev<br>git merge –no-ff  -m “注释” dev<br>可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。<a href="https://blog.csdn.net/u010940300/article/details/47419069" target="_blank" rel="noopener">分支形象理解</a></p>
<p>git branch –d dev</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Chen Bin</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/cilibili" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Bin</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
